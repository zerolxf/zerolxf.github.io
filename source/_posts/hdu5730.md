---
title: HDU 5730 Shell Necklace (16多校第一场fft+分治)
categories:
  - 数学
  - FFt
  - 
tags:
  - FFT
  - cdq
  - 
date: 2016-08-06 17:56:10
toc: 
---

#### 题意
> $已知长度为n(1\leq n \leq 10^5)的序列\{a _i\}$
> $给你n个贝壳,你可以把他分成m份,每份个数分别是b _1 ,b _2 , b _3 ...b _m $
> $ 那么你可以获得a_{b_1}  a _{b _2}  a _{b _3}...  a _{b _m} 的贡献值 ,现在问你所有不同分法的贡献值值和是多少 $
<!-- more -->

#### 分析
>	设dp[i]为数量总共为i的所有不同分法的总贡献值
>	$ dp[i+1] = dp[i] \times a_1+dp[i-1] \times a_2 + dp[i-2] \times a_3+...+dp[1] \times a_i+a_{i+1} $
>	$ dp[n] = \sum_{i=1} ^{n}dp[n-i]*a_i $
>	具有多项式形式可以考虑fft，但是直接会T，考虑cdq分治，每次分治时跑fft即可

其实具体为什么这样可以我都不是很清楚,附送两发fft学习链接[fft流程图](http://wenku.baidu.com/view/8bfb0bd476a20029bd642d85.html )和[DFT原理](http://wlsyzx.yzu.edu.cn/kcwz/szxhcl/kechenneirong/jiaoan/jiaoan3.htm )以及[kuangbin博客](http://www.cnblogs.com/kuangbin/p/3210565.html)


#### 代码

``` cpp

//*************************************************************************
    > File Name: hdu5730.cpp
    > Author: liangxianfeng
    > Mail:   liangxianfeng96@qq.com
    > Created Time: 2016年07月25日 星期一 11时27分08秒
 ************************************************************************/

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<stack>
#include<map>
#include<set>
#include<vector>
#include<queue>
#include<string>
#include<cmath>
#include<complex>
using namespace std;
#define ll long long
#define rep(i,n) for(int i =0; i < n; ++i)
#define CLR(x) memset(x,0,sizeof x)
#define MEM(a,b) memset(a,b,sizeof a)
#define pr(x) cout << #x << " = " << x << " ";
#define prln(x) cout << #x << " = " << x <<  endl; 
const int maxn = 4e5+100;
const int INF = 0x3f3f3f3f;
const double PI = acos(-1);
typedef complex<double> cmx;
cmx x[maxn], y[maxn];
int a[maxn], dp[maxn], n;

void change(cmx x[], int len){

    for(int i = 1, j = len/2; i < len-1; ++i){
        if(i < j) swap(x[i], x[j]);
        int k = len/2;
        while(j >= k){
            j -= k;
            k /= 2;
        }
        while(j < k) j+= k;
    }
}
void fft(cmx x[], int len, int on){
    change(x, len);
    for(int i = 2; i <= len; i <<= 1){
        cmx wn(cos(-on*2*PI/i), sin(-on*2*PI/i));
        for(int j = 0; j < len; j += i){
            cmx w(1,0);
            for(int k = j; k < j + i/2; ++k){
                cmx u = x[k];
                cmx v = x[k+i/2]*w;
                x[k] = u + v;
                x[k+i/2] = u-v;
                w *= wn;
            }
        }
    }
    if(on == -1){
        for(int i = 0; i < len; ++i){
            x[i] /= len;
        }
    }
}
const int MOD = 313;
void cdq(int l, int r){
    if(l == r){
        dp[l] += a[l];
        dp[l] %= MOD;
        return;
    }
    int mid = (l + r) >> 1;
    cdq(l, mid);
    int len = 1;
    while(len <= (r-l+1)) len <<= 1;
    rep(i,len) x[i] = y[i] = cmx(0,0);
    for(int i = l; i <= mid; ++i){
        x[i-l] = cmx(dp[i], 0);
    }
    for(int i = 1; i <= r-l; ++i){
        y[i-1] = cmx(a[i], 0);
    }
    fft(x, len, 1);
    fft(y, len, 1);
    for(int i = 0; i < len; ++i){
        x[i] *= y[i];
    }
    fft(x, len, -1);
    for(int i = mid+1; i <= r; ++i){
        dp[i] += (int)(x[i-l-1].real() + 0.5);
        dp[i] %= MOD;
    }
    cdq(mid+1, r);
}
int main(){
#ifdef LOCAL
	freopen("/home/zeroxf/桌面/in.txt","r",stdin);
	//freopen("/home/zeroxf/桌面/out.txt","w",stdout);
#endif
    while(cin >> n && n){
        MEM(dp, 0);
        for(int i = 1; i <= n; ++i){
            scanf("%d", &a[i]);
            a[i] %= MOD;
        }
        cdq(1, n);
        cout << dp[n] << "\n";
    }
	return 0;
}
```
