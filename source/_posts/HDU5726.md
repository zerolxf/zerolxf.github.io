---
title: HDU 5726 GCD (16多校第一场)
categories:
  - 随笔
  - 技巧
  - 
tags:
  - gcd
  - 
  - 
date: 2016-08-06 15:10:10
toc: 
---

#### 题意
>$给你一个长度为n(1\leq n \leq 100000)序列:a _1,a _2, a_3...(1 \leq a _i \leq 10 ^9 )$
>$现在给你q个查询,每个查询问你存在多少个区间gcd的值等于区间[l,r]区间的gcd值$

<!-- more -->
#### 分析

-	第一步使用倍增可以很快求出区间[l,r]的gcd的值
-	**如何很快的统计**有多少个区间的gcd值等于x?

>	$这里需要认识到一个性质,以某一个数字开始往后gcd的值只会减少不会增加,因而最多有log _2 x$
>	$所以这里我们可以记录以某一个位置开始或结束所有区间gcd的状态即可$
>	$eg: dp[i]记录以位置i结尾所有区间gcd的值以及个数$
    $则有dp[i+1]=dp[i]+gcd(dp[i],a[i+1])$

刚开始以为不能用map,后面直接map过了,使用map映射转移的话复杂度是nlog$ ^2 n $


```cpp
/*************************************************************************
	> File Name: d.cpp
	> Author: liangxianfeng
	> Mail:   liangxianfeng96@qq.com
	> Created Time: 2016年07月19日 星期二 17时52分44秒
 ************************************************************************/

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<stack>
#include<map>
#include<set>
#include<vector>
#include<queue>
#include<string>
#include<cmath>
using namespace std;
#define ll long long
#define rep(i,n) for(int i =0; i < n; ++i)
#define CLR(x) memset(x,0,sizeof x)
#define MEM(a,b) memset(a,b,sizeof a)
#define pr(x) cout << #x << " = " << x << " ";
#define prln(x) cout << #x << " = " << x <<  endl; 
const int maxn = 2e6+100;
const int INF = 0x3f3f3f3f;
const int HASHSIZE = 1e5+7;

int a[maxn];
const int N = 60;

int n, m;
int gcd(int x, int y){
    if(y==0) return x;
    return  gcd(y, x%y);
}
int sum[maxn];
void build(int rt, int l, int r){
    if(l == r){
        scanf("%d", &a[l]);
        sum[rt] = a[l];
        return;
    }
    int m = (l + r) >> 1;
    build(rt<<1, l, m);
    build(rt<<1|1, m+1, r);
    sum[rt] = gcd(sum[rt<<1], sum[rt<<1|1]);
}
int query(int rt, int l, int r, int ql, int qr){
    if(ql <= l && r <= qr){
        return sum[rt];
    }
    int m = (l + r) >> 1;
    if(qr <= m) return query(rt<<1, l, m, ql, qr);
    else if(ql > m) return query(rt<<1|1, m+1, r, ql, qr);
    else{
        return gcd(query(rt<<1, l, m, ql, qr), query(rt<<1|1, m+1, r, ql, qr));
    }
}
int l[maxn], r[maxn];
int num[maxn], ans[maxn];
map<int, ll> ha, mp[2];
int dp[20][123456];
int getlen(int x){
    int ans = 0;
    while(x){
        ans++;
        x>>=1;
    }
    return ans;
}
int main(){
#ifdef LOCAL
	freopen("/home/zeroxf/桌面/in.txt","r",stdin);
	//freopen("/home/zeroxf/桌面/out.txt","w",stdout);
#endif
    int t;
    scanf("%d", &t);
    int kase = 0;
    while(t--){
        scanf("%d", &n);
        for(int i = 1; i <= n; ++i){
            scanf("%d", &dp[0][i]);
        }
        for(int i = 1; (1<<i)<=n; ++i){
            for(int j = 1; j <= n; ++j){
                dp[i][j] = gcd(dp[i-1][j], dp[i-1][j+(1<<(i-1))]);
            }
        }
        scanf("%d", &m);
        int x, y;
        for(int i = 0; i < m; ++i){
            scanf("%d%d", &x, &y);
            int len = getlen(y-x+1) -1;
            num[i] = gcd(dp[len][x], dp[len][y-(1<<len)+1]);
        }
        int now = 0, pre = 1;
        mp[0].clear();
        mp[1].clear();
        ha.clear();
        for(int i = 1; i <= n; ++i){
            swap(now,pre);
            mp[now].clear();
            for(auto itr = mp[pre].begin(); itr != mp[pre].end(); itr++){
               int temp = gcd(dp[0][i], itr->first);
               mp[now][temp] += itr->second;
            }
            mp[now][dp[0][i]]++;
            for(auto itr = mp[now].begin(); itr != mp[now].end(); itr++){
                ha[itr->first] += itr->second;
            }

        }
        printf("Case #%d:\n",++kase);
        for(int i = 0; i < m; ++i){
            //prln(num[i]);
            printf("%d %lld\n", num[i], ha[num[i]]);
        }
        
    }
	return 0;
}
```
