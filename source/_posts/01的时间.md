---
title: 01的时间
date: 2016-05-10 22:01:50
tags: dp
---

### 01的时间

#### 题意

给你一个数x，让你找到x的倍数，同时这个倍数只能包含01数字(十进制)，输出最小的符合条件的

#### 分析

1.这题本意是想让我们用搜索的，但写过数位dp后对这题第一反应就是可以dp啊。dp[i][j][0]表示当前i长度余j并且第i位取0可不可达，同理dp[i][j][1]。

首先预处理出当第i位是1时对x取模的余数
状态转移的话dp[i][j][0] |= dp[i-1][j][0] || dp[i-1][j][1],dp[i][j][1] |= dp[i-1][(j-base[j]+x)%x][0] || dp[i-1][(j-base[j]+x)%x][1]; 

2.全部切忌初始化0,dp[0][0][0] = 1;


#### 思考

1.前面的转移式是最基本的转移，但实际转移中为了回溯更方便可以dp记录上一位的取值情况，不可到达初始为-1,这里刚开始我把dp所存的值弄混淆了，存了当前的最小值是多少，同时还开了一个辅助flag作为标记能不能可达。但是，后面想一想，完全没必要。因为当状态转移好之后，第一个首位是1并且取余是0的状态就是最小的(这个可以反向想一下)。找到最小的状态之后，剩下的就是往回找，看前一个是由谁转移来的。


2.上述过程有一个性质就是，对于所找到的第一个符合条件首位是1的数字，他的之前所有状态都只有一个前述状态。为什么？假如他可以由两个状态转移y,z转移过来，那么(y-z)%x==0,那么就会出现一个比当前更小的符合条件的
