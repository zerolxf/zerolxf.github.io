---
title: 神舟的宝藏
date: 2016-05-11 2:40:00
tags: 数位dp
categories:
- 川大重大联合赛
- 第一场联合赛
---


#### 题意

让你找这样一个密码：

- 密码是一个C进制的数； 
- 密码由给定的M个数字构成；
- 密码是一个给定N的十进制整数的正整数倍；
- 如果存在多个满足上面所有条件的数字，值最小数字就是密码； 
- 系统输入上限为500位数字，如果求出的密码长度大于500位，则也不能打开房门。

其中C，M不超过16，N不超过5000
<!-- more -->
#### 分析

1. 这题相当于01的时间的**进阶版**。写起来就很简单了：我们预处理的时候要以C进制为基础预处理第i为是M个数字中的某一个是对N取模的余数是多少。dp[i][j]表示长度为i，对N余数是j这样状态第i位是哪一个数字

2. 这题和之前的有两个不一样是


- 我不确定0有没有，如果有0的话我要特殊判断当前是0.状态转移的时候从最小数值开始转移**(当余数j是0的时候不包含0，因为这个时候如果能用其他数值更新那么后面就不需要再添加数字了，如果用0更新的话就会出现前导0还需要继续添加位数这样就不是最小的)**，就能够保证后面得到相同状态的时候值最小。
- 状态使用dp[i][j]而不像C题那样使用dp[i][j][k]多出来的K表示当前位取第K个数字，这样的添加了状态数和转移数，使得转移复杂度变得高很多，内存也不划算

#### 思考
1. 像上面所说的那样从最小数字更新，这样一旦更新了，我就不准二次更新了，不需要比较值了，这样dp就可以“安心”记录上一个状态的值了

2. 这题容易处理错0这个数字，如果更新的时候把0放在最先，那么dp[i][0]永远都只会被0更新，而这是非法的（就好比是00000000...）。如果不把0放到最前面，那么处理余数非0的状态时候明可以用0来更新，而被用非0数字更新这样会导致所求的不是最小的数值。


```cpp
/*************************************************************************
	> File Name: g.cpp
	> Author: liangxianfeng
	> Mail:   641587852@qq.com
	> Created Time: 2016年05月04日 星期三 17时29分57秒
 ************************************************************************/

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<stack>
#include<map>
#include<set>
#include<vector>
#include<queue>
#include<string>
#include<cmath>
using namespace std;
#define ll long long
#define rep(i,n) for(int i =0; i < n; ++i)
#define CLR(x) memset(x,0,sizeof x)
#define MEM(a,b) memset(a,b,sizeof a)
#define pr(x) cout << #x << " = " << x << " ";
#define prln(x) cout << #x << " = " << x <<  endl; 
const int maxn = 4e5+100;
const int INF = 0x3f3f3f3f;
int dp[550][5500];
int num[550][20];
int a[20];
char s[30];
int t, n, m, c;
void getnum(int m, int n) {
    for(int i = 0; i < m; ++i){
        num[1][i] = a[i]%n;
    }
    for(int i = 2; i <= 500; ++i){
        for(int j = 0; j < m; ++j){
            num[i][j] = num[i-1][j]*c%n;
        }
    }
}
int main(){
#ifdef LOCAL
	freopen("/home/zeroxf/桌面/in.txt","r",stdin);
	//freopen("/home/zeroxf/桌面/out.txt","w",stdout);
#endif
    for(int i = 0; i <= 15; ++i){
        s[i] = i+'0';
        if(i >= 10) s[i] = 'A' + i-10;
    }
    scanf("%d", &t);
    while(t--){
        char ss[20];
        scanf("%d%d%d", &n, &c, &m);
        for(int i = 0; i < m; ++i){
            scanf("%s", ss);
            if(ss[0] <= '9' && ss[0] >= '0') a[i] = ss[0] -'0';
            else a[i] = ss[0] - 'A' + 10;
        }
        sort(a,a+m);
        a[m] = a[0];
        getnum(m,n);
        int len = 500;
        for(int i = 0; i <= len; ++i){
            for(int j = 0; j <= n; ++j){
                dp[i][j] = -1;
            }
        }
        dp[0][0] = 0;
        bool ok = false;
        for(int i = 1; i <= len; ++i){
            for(int j = 0; j < n; ++j){
                for(int k = 0; k < m; ++k){
                    if(a[k] == 0 && j == 0) continue;
                    if(dp[i-1][(j+n-num[i][k])%n] != -1 && dp[i][j] == -1){
                        dp[i][j] = k;
                        if(j==0) ok = true;
                        break;
                    }
                }
                if(j==0&&a[0]==0)
                if(dp[i-1][(j+n-num[i][0])%n] != -1 && dp[i][j] == -1){
                    dp[i][j] = 0;
                }
                if(ok) break;
            }
            if(ok) break;
        }
        int ans = -1, pos;
        for(int i = 1; i <= len; ++i){
            if(dp[i][0] != -1 && a[dp[i][0]] != 0){
                ans = dp[i][0];
                pos = i;
                break;
            }
        }
        if(ans == -1) {
            printf("BOMB!!!\n");
            continue;
        }
        int l = 0;
        while(pos > 0 && ans != -1){
            ans = dp[pos][l];
            printf("%c", s[a[ans]]);
            l = (l-num[pos][ans]+n)%n;
            pos--;
        }
        printf("\n");
    }
	return 0;
}

```