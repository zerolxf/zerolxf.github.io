<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  C 语言学习 小记 - zeroxf
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="zeroxf" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:zerolxf.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_blank" href="index.html">Home</a></li>
        
        <li id=""><a target="_blank" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_blank" href="categories.html">分类</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; zeroxf</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_blank" href="index.html">Home</a></li>
        
        <li><a target="_blank" href="archives.html">Archives</a></li>
        
        <li><a target="_blank" href="categories.html">分类</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="gpt_paper.html.html">GPT 读论文</a></li>
        
            <li><a href="%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8.html">配置使用</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="c++.html">c++</a></li>
        
            <li><a href="%E6%95%B0%E5%AD%A6&%E4%BC%98%E5%8C%96&%E7%AE%97%E6%B3%95.html">数学&优化&算法</a></li>
        
            <li><a href="python.html">python</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>C 语言学习 小记</h1>
     
        <div class="read-more clearfix">
          <span class="date">2023/08/07</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='c++.html'>c++</a></span>
           
         
          <span class="comments">
            
              <a href="https://zerolxf.github.io/16913482390348.html#disqus_thread">comments</a>
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <p>在github上面看到别人一个很不错的学习笔记，记录一下其中的知识点<br />
<a href="https://github.com/qyuhen/bookPDF">笔记</a>by qyuhen</p>
<blockquote>
<p>记录一下学习c语言遇到的一些知识点</p>
</blockquote>
<span id="more"></span><!-- more -->
<h2><a id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据类型</h2>
<h3><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串</h3>
<p>字符常量默认是⼀个 int 整数，但编译器可以⾃⾏决定将其解释为 char 或 int。<br />
<code> size('a') = 4</code></p>
<h3><a id="%E6%B5%AE%E7%82%B9%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>浮点数</h3>
<ul>
<li>float: 32 位 4 字节浮点数，精确度 6。</li>
<li>double: 64 位 8 字节浮点数，精确度 15。</li>
<li>long double: 80 位 10 字节浮点数，精确度 19 位。</li>
</ul>
<p>C99 提供了复数⽀持，⽤两个相同类型的浮点数分别表⽰复数的实部和虚部。<br />
直接在 float、 double、 long double 后添加 _Complex 即可表⽰复数，在 complex.h 中定义了<br />
complex 宏使得显⽰更统⼀美观</p>
<pre class="line-numbers"><code class="language-plain_text">float complex size=8
double complex size=16
long double complex size=24
</code></pre>
<h3><a id="%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举</h3>
<p>enum中的值可以自定义，之后的会依次递增，值可以相同</p>
<pre class="line-numbers"><code class="language-plain_text">enum color { black, red = 5, green, yellow };
enum color b = black;
printf(&quot;black = %d\n&quot;, b);
...
black = 0
red = 5
green = 6
yellow = 7
----------------------------------------
enum color { black = 1, red, green = 1, yellow };
black = 1
red = 2
green = 1
yellow = 2
</code></pre>
<p>通常省略枚举⼩标签⽤来代替宏定义常量</p>
<pre class="line-numbers"><code class="language-plain_text">

----------------------------------------
enum { BLACK = 1, RED, GREEN = 1, YELLOW };
printf(&quot;black = %d\n&quot;, BLACK);
printf(&quot;red = %d\n&quot;, RED);
printf(&quot;green = %d\n&quot;, GREEN);
printf(&quot;yellow = %d\n&quot;, YELLOW);
</code></pre>
<h2><a id="%E5%AD%97%E9%9D%A2%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字面值</h2>
<h3><a id="%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整数常量</h3>
<p>常量类型很重要，可以通过后缀来区分类型。</p>
<pre class="line-numbers"><code class="language-plain_text">0x200 -&gt; int
200U -&gt; unsigned int
0L -&gt; long
0xf0f0UL -&gt; unsigned long
0777LL -&gt; long long
0xFFULL -&gt; unsigned long long
</code></pre>
<h3><a id="%E6%B5%AE%E7%82%B9%E5%B8%B8%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>浮点常量</h3>
<p>默认浮点常量是 double，可以⽤ F 后缀表⽰ float，⽤ L 后缀表⽰ long double 类型。</p>
<h3><a id="%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符常量</h3>
<p>字符常量默认是 int 类型，除⾮⽤前置 L 表⽰ wchar_t 宽字符类型。</p>
<h3><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串常量</h3>
<p>C 语⾔中的字符串是⼀个以 NULL (也就是 \0) 结尾的 char 数组。<br />
空字符串在内存中占⽤⼀个字节，包含⼀个 NULL 字符，也就是说要表⽰⼀个⻓度为 1 的字符串最少需要 2 个字节 (strlen 和 sizeof 表⽰的含义不同)。</p>
<pre class="line-numbers"><code class="language-plain_text">wchar_t ws[] = L&quot;中国⼈&quot;;
printf(&quot;len %d, size %d\n&quot;, wcslen(ws), sizeof(ws));
unsigned char* b = (unsigned char*)ws;
int len = sizeof(ws);
for (int i = 0; i &lt; len; i++)
{
    printf(&quot;%02X &quot;, b[i]);
}
</code></pre>
<p>wchar_t 字符串以⼀个 4 字节的 NULL 结束<br />
输出:</p>
<pre class="line-numbers"><code class="language-plain_text">len 3, size 16
2D 4E 00 00 FD 56 00 00 BA 4E 00 00 00 00 00 00
</code></pre>
<p>编译器会⾃动连接相邻的字符串，这也便于我们在宏或者代码中更好地处理字符串。</p>
<pre class="line-numbers"><code class="language-plain_text">#define WORLD &quot;world!&quot;
char* s = &quot;Hello&quot; &quot; &quot; WORLD &quot;\n&quot;;
</code></pre>
<p>对于源代码中超⻓的字符串，除了使⽤相邻字符串外，还可以⽤ &quot;&quot; 在⾏尾换⾏。</p>
<pre class="line-numbers"><code class="language-plain_text">char* s1 = &quot;Hello&quot;
&quot; World!&quot;;
char* s2 = &quot;Hello \
World!&quot;;
</code></pre>
<h2><a id="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型转换</h2>
<h3><a id="%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算术类型转换</h3>
<p>在表达式中，可能会将 char、 short 当做默认 int (unsigned int) 类型操作数，但 float 并不会⾃动转换为默认的 double 类型。</p>
<p>当包含⽆符号操作数时，需要注意提升后类型是否能容纳⽆符号类型的所有值。</p>
<pre class="line-numbers"><code class="language-plain_text">long a = -1L;
unsigned int b = 100;
printf(&quot;%ld\n&quot;, a &gt; b ? a : b);
</code></pre>
<p>输出:</p>
<pre class="line-numbers"><code class="language-plain_text">-1
</code></pre>
<p>输出结果让⼈费解。尽管 long 等级⽐ unsigned int ⾼，但在 32 位系统中，它们都是 32 位整数，<br />
且 long 并不⾜以容纳 unsigned int 的所有值，因此编译器会将这两个操作数都转换为 unsigned<br />
long，也就是⾼等级的⽆符号版本，如此 (unsigned long)a 的结果就变成了⼀个很⼤的整数。</p>
<p><em>可以显式将指针转换为整数，反向转换亦可</em></p>
<h2><a id="%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运算符</h2>
<p>C99 新增的内容，我们可以直接⽤该语法声明⼀个结构或数组指针。<br />
(类型名称){ 初始化列表 }</p>
<pre class="line-numbers"><code class="language-plain_text">int* i = &amp;(int){ 123 }; ! // 整型变量, 指针
int* x = (int[]){ 1, 2, 3, 4 }; ! // 数组, 指针
struct data_t* data = &amp;(struct data_t){ .x = 123 }; ! // 结构, 指针
</code></pre>
<p>int* i = &amp;(int){ 123 }; ! // 整型变量, 指针<br />
int* x = (int[]){ 1, 2, 3, 4 }; ! // 数组, 指针<br />
struct data_t* data = &amp;(struct data_t){ .x = 123 }; ! // 结构, 指针</p>
<p><strong>不要⽤ int 代替 size_t，因为在 32 位和 64 位平台 size_t ⻓度不同</strong></p>
<h3><a id="%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逗号运算符</h3>
<p>逗号是⼀个⼆元运算符，确保操作数从左到右被顺序处理，并返回右操作数的值和类型</p>
<pre class="line-numbers"><code class="language-plain_text">int i = 1;
long long x = (i++, (long long)i);
printf(&quot;%lld\n&quot;, x);

</code></pre>
<h2><a id="%E8%AF%AD%E5%8F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>语句</h2>
<h3><a id="%E8%AF%AD%E5%8F%A5%E5%9D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>语句块</h3>
<p>语句块代表了⼀个作⽤域，在语句块内声明的⾃动变量超出范围后⽴即被释放。除了⽤ &quot;{...}&quot; 表⽰⼀<br />
个常规语句块外，还可以直接⽤于复杂的赋值操作，这在宏中经常使⽤。</p>
<pre class="line-numbers"><code class="language-plain_text">int i = ({ char a = 'a'; a++; a; });
printf(&quot;%d\n&quot;, i);
</code></pre>
<h3><a id="%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>选择语句</h3>
<p>除了<code> if...else if...else...</code> 和 <code>switch { case ... } </code>还有谁呢。<br />
GCC ⽀持 switch 范围扩展。神奇！</p>
<pre class="line-numbers"><code class="language-plain_text">int x = 1;
switch (x)
{
    case 0 ... 9: printf(&quot;0..9\n&quot;); break;
    case 10 ... 99: printf(&quot;10..99\n&quot;); break;
    default: printf(&quot;default\n&quot;); break;
}
char c = 'C';
switch (c)
{
    case 'a' ... 'z': printf(&quot;a..z\n&quot;); break;
    case 'A' ... 'Z': printf(&quot;A..Z\n&quot;); break;
    case '0' ... '9': printf(&quot;0..9\n&quot;); break;
    default: printf(&quot;default\n&quot;); break;
}
</code></pre>
<p>最后⼀个表达式被当做语句块的返回值</p>
<h3><a id="%E2%BD%86%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>⽆条件跳转</h3>
<p>⽆条件跳转: break, continue, goto, return。<br />
goto 仅在函数内跳转，常⽤于跳出嵌套循环。如果在函数外跳转，可使⽤ longjmp。<br />
5.4.1 longjmp<br />
setjmp 将当前位置的相关信息 (堆栈帧、寄存器等) 保存到 jmp_buf 结构中，并返回 0。当后续代码执⾏ longjmp 跳转时，需要提供⼀个状态码。代码执⾏绪将返回 setjmp 处，并返回 longjmp所提供的状态码。</p>
<pre class="line-numbers"><code class="language-plain_text">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;setjmp.h&gt;
void test(jmp_buf *env)
{
    printf(&quot;1....\n&quot;);
    longjmp(*env, 10);
}
int main(int argc, char* argv[])
{
    jmp_buf env;
    int ret = setjmp(env); ! // 执⾏ longjmp 将返回该位置， ret 等于 longjmp 所提供的状态码。
    if (ret == 0)
    {
        test(&amp;env);
    }
    else
    {
        printf(&quot;2....(%d)\n&quot;, ret);
    }
    return EXIT_SUCCESS;
}
</code></pre>
<p>输出:</p>
<pre class="line-numbers"><code class="language-plain_text">1....
2....(10)
</code></pre>
<h2><a id="%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数</h2>
<h3><a id="%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用</h3>
<p>C 函数默认采⽤ cdecl 调⽤约定，参数从右往左⼊栈，且由调⽤者负责参数⼊栈和清理.</p>
<pre class="line-numbers"><code class="language-plain_text">int main(int argc, char* argv[])
{
    int a()
    {
        printf(&quot;a\n&quot;);
        return 1;
    }
    char* s()
    {
    printf(&quot;s\n&quot;);
    return &quot;abc&quot;;
    }
    printf(&quot;call: %d, %s\n&quot;, a(), s());
    return EXIT_SUCCESS;
}
</code></pre>
<p>输出:</p>
<pre class="line-numbers"><code class="language-plain_text">s a
call: 1, abc
</code></pre>
<h3><a id="%E5%8F%AF%E9%80%89%E6%80%A7%E2%BE%83%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可选性⾃变量</h3>
<p>具体参考<a href="https://github.com/qyuhen/bookPDF">PDF</a></p>
<h2><a id="%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数组</h2>
<h3><a id="%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可变长度数组</h3>
<p>如果数组具有⾃动⽣存周期，且没有 static 修饰符，那么可以⽤⾮常量表达式来定义数组</p>
<pre class="line-numbers"><code class="language-plain_text">void test(int n)
{
    int x[n];
    for (int i = 0; i &lt; n; i++)
    {
        x[i] = i;
    }
    struct data { int x[n]; } d;
    printf(&quot;%d\n&quot;, sizeof(d));
}
int main(int argc, char* argv[])
{
    int x[] = { 1, 2, 3, 4 };
    printf(&quot;%d\n&quot;, sizeof(x));
    test(2);
    return EXIT_SUCCESS;
}
</code></pre>
<p>初始化规则:</p>
<ul>
<li>如果数组为静态⽣存周期，那么初始化器必须是常量表达式。</li>
<li>如果提供初始化器，那么可以不提供数组⻓度，由初始化器的最后⼀个元素决定。</li>
<li>如果同时提供⻓度和初始化器，那么没有提供初始值的元素都被初始化为 0 或 NULL。</li>
</ul>
<p><strong>初始化特定元素</strong></p>
<pre class="line-numbers"><code class="language-plain_text">int x[] = { 1, 2, [6] = 10, 11 };
int len = sizeof(x) / sizeof(int);
for (int i = 0; i &lt; len; i++)
{
    printf(&quot;x[%d] = %d\n&quot;, i, x[i]);
}
---------------------------------------
输出:
x[0] = 1
x[1] = 2
x[2] = 0
x[3] = 0
x[4] = 0
x[5] = 0
x[6] = 10
x[7] = 11
</code></pre>
<h3><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串</h3>
<p>字符串是以 '\0' 结尾的 char 数组, 这里体现在<code>sizeof</code></p>
<pre class="line-numbers"><code class="language-plain_text">char s[10] = &quot;abc&quot;;
char x[] = &quot;abc&quot;;
printf(&quot;s, size=%d, len=%d\n&quot;, sizeof(s), strlen(s));
printf(&quot;x, size=%d, len=%d\n&quot;, sizeof(x), strlen(x));
</code></pre>
<p>输出:</p>
<pre class="line-numbers"><code class="language-plain_text">s, size=10, len=3
x, size=4, len=3
</code></pre>
<p>同样,我们可以初始化特定的元素.</p>
<pre class="line-numbers"><code class="language-plain_text">int x[][2] =
{
    { 1, 11 },
    { 2, 22 },
    { 3, 33 },
    [4][1] = 100,
    { 6, 66 },
    [7] = { 9, 99 }
};
</code></pre>
<h3><a id="%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数组参数</h3>
<p>参见<a href="https://github.com/zerolxf/ShareFolder">PDF</a></p>
<h2><a id="%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>指针</h2>
<p>⾮⾃动周期指针变量或静态⽣存期指针变量必须⽤编译期常量表达式初始化，⽐如函数名称等</p>
<h3><a id="%E9%99%90%E5%AE%9A%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>限定符</h3>
<p>限定符 const 可以声明 &quot;类型为指针的常量&quot; 和 &quot;指向常量的指针&quot;<br />
区别在于 const 是修饰 p 还是 *p</p>
<h2><a id="%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构</h2>
<p>结构类型⽆法把⾃⼰作为成员类型，但可以包含 &quot;指向⾃⼰类型&quot; 的指针成员</p>
<pre class="line-numbers"><code class="language-plain_text">struct list_node
{
struct list_node* prev;
struct list_node* next;
void* value;
};
</code></pre>
<p>定义不完整结构类型，只能使⽤⼩标签，像下⾯这样的 typedef 类型名称是不⾏的。</p>
<pre class="line-numbers"><code class="language-plain_text">typedef struct
{
list_node* prev;
list_node* next;
void* value;
} list_node;
----------------------------
//结合起来用
typedef struct node_t
{
    struct node_t* prev;
    struct node_t* next;
    void* value;
} list_node;
----------------------------
//⼩标签可以和 typedef 定义的类型名相同。
typedef struct node_t
{
    struct node_t* prev;
    struct node_t* next;
    void* value;
} node_t;
</code></pre>
<h3><a id="%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>匿名结构</h3>
<p>在结构体内部使⽤匿名结构体成员，也是⼀种很常⻅的做法</p>
<pre class="line-numbers"><code class="language-plain_text">typedef struct
{
    struct
    {
        int length;
        char chars[100];
    } s;
    int x;
} data_t;
int main(int argc, char * argv[])
{
    data_t d = { .s.length = 100, .s.chars = &quot;abcd&quot;, .x = 1234 };
    printf(&quot;%d\n%s\n%d\n&quot;, d.s.length, d.s.chars, d.x);
    return EXIT_SUCCESS;
}
</code></pre>
<h3><a id="%E6%88%90%E5%91%98%E5%81%8F%E7%A7%BB%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员偏移量</h3>
<p>利⽤ stddef.h 中的 ofsetof 宏可以获取结构成员的偏移量</p>
<pre class="line-numbers"><code class="language-plain_text">typedef struct
{
    struct
    {
        int length;
        char chars[100];
    } s;
    int x;
} data_t;
int main(int argc, char * argv[])
{
    data_t d = { .s.length = 100, .s.chars = &quot;abcd&quot;, .x = 1234 };
    printf(&quot;%d\n%s\n%d\n&quot;, d.s.length, d.s.chars, d.x);
    return EXIT_SUCCESS;
}

</code></pre>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="16913483067290.html" 
          title="Previous Post: 递推关系与生成函数">&laquo; 递推关系与生成函数</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="16913469570649.html" 
          title="Next Post: Java 模拟 58登录 （一） 分析">Java 模拟 58登录 （一） 分析 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          
            <div id="disqus_thread"></div>
          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="https://avatars.githubusercontent.com/u/12774971?v=4" /></div>
            
                <h1>zeroxf</h1>
                <div class="site-des"></div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/zerolxf" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:liangxianfeng96@qq.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="gpt_paper.html.html"><strong>GPT 读论文</strong></a>
        
            <a href="%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8.html"><strong>配置使用</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="c++.html"><strong>c++</strong></a>
        
            <a href="%E6%95%B0%E5%AD%A6&%E4%BC%98%E5%8C%96&%E7%AE%97%E6%B3%95.html"><strong>数学&优化&算法</strong></a>
        
            <a href="python.html"><strong>python</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16913487231002.html">搭建正向反向代理</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16913486248203.html">二阶随机优化算法</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16913485508310.html">Pandas 读取文本数据</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16913485233251.html">Pandas 数据整合</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16913485004157.html">Python 数据分析画图&one-hot编码</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>


<script type="text/javascript">
    var disqus_shortname = 'zeroxf'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<script type="text/javascript">
var disqus_shortname = 'zeroxf'; 

(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
