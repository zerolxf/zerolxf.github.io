<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>-0你的电脑炸了</title>
    <url>/2016/06/07/-0%E4%BD%A0%E7%9A%84%E7%94%B5%E8%84%91%E7%82%B8%E4%BA%86/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>现在有16个格子9个应用,每个应用覆盖4个格子,每个格子可能会有多个应用覆盖,但是最上面那个应用会显示出来,现在给你最终的16个格子的显示情况问你这种情况存不存在</p>
<span id="more"></span>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>每个格子存有一个应用,最上面那个应用拓扑序大于当前其他应用,因而得到很多个拓扑关系,只要看这个拓扑关系存不存在就好了</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.没啥坑点,就是实现的时候稍微有点麻烦,不过for1到9把1到9填充到16个vector中就好</p>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第三场联合赛</category>
      </categories>
      <tags>
        <tag>拓扑序</tag>
      </tags>
  </entry>
  <entry>
    <title>01的时间</title>
    <url>/2016/05/10/01%E7%9A%84%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h3 id="01的时间"><a href="#01的时间" class="headerlink" title="01的时间"></a>01的时间</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给你一个数x，让你找到x的倍数，同时这个倍数只能包含01数字(十进制)，输出最小的符合条件的</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.这题本意是想让我们用搜索的，但写过数位dp后对这题第一反应就是可以dp啊。<br>dp[i][j][0]表示当前i长度余j并且第i位取0可不可达，同理dp[i][j][1]。</p>
<p>首先预处理出当第i位是1时对x取模的余数状态转移的话<br>*dp[i][j][0] |&#x3D; dp[i-1][j][0] || dp[i-1][j][1];<br>dp[i][j][1] |&#x3D; dp[i-1][(j-base[j]+x)%x][0] || dp[i-1][(j-base[j]+x)%x][1]; *</p>
<p>2.全部切记初始化0,dp[0][0][0] &#x3D; 1;</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li><p>1.这里刚开始我把dp所存的值弄混淆了，存了当前的最小值是多少，同时还开了一个辅助flag作为标记能不能可达。但是，后面想一想，完全没必要。因为当状态转移好之后，第一个首位是1并且取余是0的状态就是最小的(这个可以反向想一下)。找到最小的状态之后，剩下的就是往回找，看前一个是由谁转移来的。</p>
</li>
<li><p>2.前面的转移式是最基本的转移，但实际转移中为了回溯更方便可以dp记录上一位的取值情况，不可到达初始为-1. 当有两种可选的状态的时候选较小的。</p>
</li>
<li><p>3.我曾经错误以为：上述过程有一个性质就是，对于所找到的第一个符合条件首位是1的数字，他的之前所有状态都只有一个前述状态。<strong>为什么？</strong></p>
</li>
<li><p>4.假如他可以由两个状态转移y,z转移过来，那么(y-z)%x&#x3D;&#x3D;0,那么就会出现一个比当前更小的符合条件的。但是后面想一想（y-z）可能不符合只含01这个条件。（但是如果没有这个限制的话，这就是一个可以利用的性质）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: c.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月02日 星期一 22时07分26秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> num[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>%x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">250</span>; ++i)&#123;</span><br><span class="line">        num[i] = num[i<span class="number">-1</span>]*<span class="number">10</span>%x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> x, <span class="type">int</span> mod, <span class="type">bool</span> ok)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="number">0</span> &amp;&amp; ok) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = pos<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> flag, last;</span><br><span class="line">&#125;;</span><br><span class="line">Node dp[<span class="number">512</span>][<span class="number">10512</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> n, kase;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;kase);</span><br><span class="line">    <span class="keyword">while</span>(kase--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">get</span>(n);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span> , <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">110</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>].last = dp[i][j][<span class="number">1</span>].last = <span class="number">-1</span>;</span><br><span class="line">                dp[i][j][<span class="number">1</span>].flag = dp[i][j][<span class="number">0</span>].flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].last = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>].flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j][<span class="number">0</span>].last != <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//pr(i);pr(j);pr(i+1);prln((j+num[i])%n);</span></span><br><span class="line">                    <span class="comment">//prln(dp[i][j][0].last);</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j][<span class="number">0</span>].flag)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!dp[i+<span class="number">1</span>][(j+num[i])%n][<span class="number">1</span>].flag)&#123;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j+num[i])%n][<span class="number">1</span>].flag = <span class="literal">true</span>;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j+num[i])%n][<span class="number">1</span>].last = j*<span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!dp[i+<span class="number">1</span>][(j)%n][<span class="number">0</span>].flag)&#123;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j)%n][<span class="number">0</span>].flag = <span class="literal">true</span>;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j)%n][<span class="number">0</span>].last = j*<span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!dp[i+<span class="number">1</span>][(j+num[i])%n][<span class="number">1</span>].flag)&#123;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j+num[i])%n][<span class="number">1</span>].flag = <span class="literal">true</span>;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j+num[i])%n][<span class="number">1</span>].last = j*<span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!dp[i+<span class="number">1</span>][(j)%n][<span class="number">0</span>].flag)&#123;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j)%n][<span class="number">0</span>].flag = <span class="literal">false</span>;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j)%n][<span class="number">0</span>].last = j*<span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span>(dp[i][j][<span class="number">1</span>].last != <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="comment">//pr(i);pr(j);pr(i+1);prln((j+num[i])%n);</span></span><br><span class="line">                       <span class="comment">// prln(dp[i][j][1].last);</span></span><br><span class="line">                        <span class="keyword">if</span>(!dp[i+<span class="number">1</span>][(j+num[i])%n][<span class="number">1</span>].flag)&#123;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j+num[i])%n][<span class="number">1</span>].flag = <span class="literal">true</span>;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j+num[i])%n][<span class="number">1</span>].last = j*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!dp[i+<span class="number">1</span>][(j)%n][<span class="number">0</span>].flag)&#123;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j)%n][<span class="number">0</span>].flag = <span class="literal">true</span>;</span><br><span class="line">                            dp[i+<span class="number">1</span>][(j)%n][<span class="number">0</span>].last = j*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">0</span>][<span class="number">1</span>].flag)&#123;</span><br><span class="line">                ans = <span class="number">1</span>;</span><br><span class="line">                pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pos != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans%<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            ans = dp[pos][ans/<span class="number">2</span>][ans%<span class="number">2</span>].last;</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 模拟 58登录 （一） 分析</title>
    <url>/2018/01/17/58login1/</url>
    <content><![CDATA[<blockquote>
<p>实习期间需要做一个模拟58登录然后爬取简历，第一次做项目遇到很多坑<br>同时网上关于58登录的又没有很多资料，遇到了很多坑，这里记录一下，方便自己以及他人学习</p>
</blockquote>
<span id="more"></span>

<p>源代码放在<a href="https://github.com/zerolxf/Login58">Github</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里是通过手机动态码的方式来登录58, 而非帐号密码, 适用于第三方网站登录使用<br>原因是模拟密码登录的时候, 当我用其他人账号在我这里登录58的时候就会出现账号登录限制<br>需要手机动态码验证之后才可以登录，所以决定直接手机动态码的登录。</p>
<!-- more -->

<p><strong>如果你知道这里的机制或者知道如何避免，请告知我<a href="mailto:&#108;&#x69;&#x61;&#x6e;&#x67;&#120;&#105;&#x61;&#x6e;&#x66;&#x65;&#110;&#103;&#57;&#x36;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#109;">&#108;&#x69;&#x61;&#x6e;&#x67;&#120;&#105;&#x61;&#x6e;&#x66;&#x65;&#110;&#103;&#57;&#x36;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#109;</a></strong></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="记录Http-Request请求"><a href="#记录Http-Request请求" class="headerlink" title="记录Http Request请求"></a>记录Http Request请求</h3><p>首先是登录58， 查看登录期间的Http Request请求<br><img src="http://oh9ex6wd2.bkt.clouddn.com/58_1.JPG" alt="request 请求"></p>
<p>其中，connect和clientid对我们模拟登录没有影响<br>可以发现大致的流程如下</p>
<blockquote>
<ul>
<li>发送Get请求（data？）， 获取 token</li>
</ul>
</blockquote>
<ul>
<li>发送Get请求（getcode？）， 请求发送手机验证码， 同时获得一个tokencode</li>
<li>发送Get请求（login？）， 输入手机号，动态码以及其他相关参数来发送登录请求</li>
<li>登录成功</li>
</ul>
<h3 id="查看登录Js代码"><a href="#查看登录Js代码" class="headerlink" title="查看登录Js代码"></a>查看登录Js代码</h3><p>我们先看下登录的关键js代码，看都需要哪些参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">codeCommitLogin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">loginClickLog</span>(<span class="string">&quot;from=PC_login_sj_dlqq&quot;</span>);</span><br><span class="line">    $(<span class="string">&quot;#loginMobileButton&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;disabled&quot;</span>, <span class="string">&quot;disabled&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> source = $(<span class="string">&quot;#source&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    <span class="keyword">var</span> mobile = $(<span class="string">&quot;#loginMobile&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    <span class="keyword">var</span> mobilecode = $(<span class="string">&quot;#loginMobilecode&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    <span class="keyword">var</span> validatecode = $(<span class="string">&quot;#validatecodeMobile&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    <span class="keyword">var</span> token = $(<span class="string">&quot;#tokenMobile&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    <span class="keyword">var</span> tokencode = $(<span class="string">&quot;#tokencodeMobile&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    <span class="keyword">var</span> path = $(<span class="string">&quot;#path&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    <span class="keyword">var</span> rsaModulus = $(<span class="string">&quot;#rsaModulusMobile&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    <span class="keyword">var</span> rsaExponent = $(<span class="string">&quot;#rsaExponentMobile&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">    <span class="keyword">var</span> timesign = (<span class="keyword">new</span> <span class="title class_">Date</span>).<span class="title function_">getTime</span>() + timespan;</span><br><span class="line">    <span class="keyword">var</span> isremember = $(<span class="string">&quot;#isremember_id_new_mobile&quot;</span>).<span class="title function_">prop</span>(<span class="string">&quot;checked&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> fingerprint = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fingerPrint != <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">        fingerprint = fingerPrint.<span class="title function_">get</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Fingerprint2</span> != <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> fp = <span class="keyword">new</span> <span class="title class_">Fingerprint2</span>;</span><br><span class="line">        <span class="keyword">var</span> finger2 = fp.<span class="title function_">get</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> finger2 = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="title function_">encryptString</span>(timesign + <span class="built_in">encodeURIComponent</span>(mobile), rsaExponent, rsaModulus);</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">&quot;//passport.58.com/mobile/pc/login?callback=?&amp;mobile=&quot;</span> + p + <span class="string">&quot;&amp;mobilecode=&quot;</span> + mobilecode + <span class="string">&quot;&amp;source=&quot;</span> + source + <span class="string">&quot;&amp;token=&quot;</span> + token + <span class="string">&quot;&amp;tokencode=&quot;</span> + tokencode + <span class="string">&quot;&amp;fingerprint=&quot;</span> + fingerprint + <span class="string">&quot;&amp;isremember=&quot;</span> + isremember + <span class="string">&quot;&amp;finger2=&quot;</span> + finger2 + <span class="string">&quot;&amp;path=&quot;</span> + path;</span><br><span class="line">    $.<span class="title function_">getJSON</span>(url, <span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">        <span class="title function_">codeSuccessCommitLoginFunction</span>(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数分析"><a href="#参数分析" class="headerlink" title="参数分析"></a>参数分析</h3><blockquote>
<ul>
<li>这里的话，finger2和fingerprint是唯一确定浏览器的参数，每个浏览器都有不同的值<br>这里直接从浏览器拷贝，没有影响</li>
</ul>
</blockquote>
<ul>
<li>timeSpan时间戳， 表示的是整个登录的时间+常数1411093327735</li>
<li>密文p， 是timesign + encodeURIComponent(mobile)的密文，rsaModulus 和 rsaExponent ，加密参数，58一直不变</li>
<li>其他参数直接和request请求一致，或者酌情设置</li>
</ul>
<h3 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h3><p>请求的URL Request</p>
<blockquote>
<p>URL:<a href="https://passport.58.com/frontend/data?callback=jQuery18308426383909637498_1515994624659&amp;_=1515994624692">https://passport.58.com/frontend/data?callback=jQuery18308426383909637498_1515994624659&amp;_=1515994624692</a></p>
</blockquote>
<p>Response</p>
<blockquote>
<p>jQuery18305434571389149673_1515995590691({“code”:0,”data”:{“remainTime”:0,”token”:”7pjUnv6fhBONHh7A_4HrN_2rH4is-gC8”,”rsaModulus”:”xxx固定值xxx”,<br>“rsaExponent”:”010001”,”totalTime”:60,”mobile”:”手机号”},”msg”:””})</p>
</blockquote>
<p>如上，其中callback参数中jQuery18308426383909637498_1515994624659和_&#x3D;1515994624692，一个表示回调的函数+时间戳，一个应该是发送请求时候的时间戳，这里可以参考jquery资料</p>
<p>那么这个请求是页面刚加载就发送的请求，从response可以看出主要是获取token参数</p>
<h3 id="获取tokencode"><a href="#获取tokencode" class="headerlink" title="获取tokencode"></a>获取tokencode</h3><p>Request URL</p>
<blockquote>
<p><a href="https://passport.58.com/mobile/getcode">https://passport.58.com/mobile/getcode</a>?</p>
</blockquote>
<p>参数<br><img src="http://oh9ex6wd2.bkt.clouddn.com/58_2.JPG" alt="参数"><br>Response</p>
<blockquote>
<p>jQuery18305434571389149673_1515995590693({“code”:0,”data”:{“exist”:0,”tokencode”:”GhxN2kozUcU8wsbkzGXbMmst8G4_0sSg”},”msg”:”动态码已发送”})</p>
</blockquote>
<h3 id="发送login请求"><a href="#发送login请求" class="headerlink" title="发送login请求"></a>发送login请求</h3><p>Request URL</p>
<blockquote>
<p><a href="https://passport.58.com/mobile/pc/login">https://passport.58.com/mobile/pc/login</a>?</p>
</blockquote>
<p>参数<br><img src="http://oh9ex6wd2.bkt.clouddn.com/58_3.JPG" alt="login参数"></p>
<p>Response</p>
<blockquote>
<p>jQuery18305434571389149673_1515995590693({“code”:0,”data”:{“fingerprint”:”84E63543A0E4DF048727E0037314879E66AE767A7311EA8C”},”msg”:”成功”})</p>
</blockquote>
<p>以上便是整个登录的流程</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于是第一次做Java项目，很多都不懂而且前期公司网不好半天才能刷出个界面，然后导致这个功能做了很久.<br>最初我试着用selenium框架去模拟登录，但是！！！公司网络不行并且我觉得这样效率太慢了就没有进行下去，后面转入Java模拟登录<br>前期很多时间都放在了去读Js代码，手动模拟添加部分cookie，以及模拟java加密过程，其实这三个后面发现都是在做无用功<br>然后自己登录成功后发现其他人账号不能登录，又转到手机动态码登录。。。</p>
<p>做这个功能最大的体会就是，做项目先不要深入的去了解某一个环节(这里我花了几天都在读js代码，Java模拟js加密)，应该显示着做出一个最简单的demo，遇到问题再去学习解决</p>
<p>最后这个模拟登录还是很在很多问题，希望有了解的人可以告诉应该怎么做才最好</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 模拟58登录(二) 实现</title>
    <url>/2018/01/28/58login2/</url>
    <content><![CDATA[<h1 id="Java-模拟58登录-二-实现"><a href="#Java-模拟58登录-二-实现" class="headerlink" title="Java 模拟58登录(二) 实现"></a>Java 模拟58登录(二) 实现</h1><blockquote>
<p>实习期间需要做一个模拟58登录然后爬取简历，之前已经写了一篇分析，现在具体实现过程</p>
</blockquote>
<span id="more"></span>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>根据之前的分析可以得出58登录的大致流程如下</p>
<blockquote>
<ul>
<li>发送Get请求（data？）， 获取 token</li>
</ul>
</blockquote>
<ul>
<li>发送Get请求（getcode？）， 请求发送手机验证码， 同时获得一个tokencode</li>
<li>发送Get请求（login？）， 输入手机号，动态码以及其他相关参数来发送登录请求</li>
<li>登录成功</li>
</ul>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>除了上述所说的步骤外，还有很多需要处理的底层实现细节，比如解析Cookie， 构造必须的参数</p>
<h4 id="设置必须参数"><a href="#设置必须参数" class="headerlink" title="设置必须参数"></a>设置必须参数</h4><ul>
<li>FINGERPRINT 和FINGERPRINT2是网页登录的时候直接抓取的，我试过随机修改后面几个数字依旧可以登录</li>
<li>JQUERYSTR 只是jquery调用时候自动生成的参数，为了不出现什么问题我也加上了</li>
<li>initTime initTime表示页面加载时间，后面加密时候需要用到的时间戳这个参数，这里所有需要的时间戳都是(需要的时间戳时刻b-initTime+ const time 1411093327735L)</li>
<li>TOKENCODE 和 TOKEN 是调用的时候获取的参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">FRONTEND_URL</span> <span class="operator">=</span> <span class="string">&quot;http://passport.58.com/frontend/data?&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">TOKENCODE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://passport.58.com/mobile/getcode?&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">LOGIN_URL</span> <span class="operator">=</span> <span class="string">&quot;https://passport.58.com/mobile/pc/login?&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">FINGERPRINT</span> <span class="operator">=</span> <span class="string">&quot;421A592E9D98DC7C0711A36033A582E84360ED23C621CCE3_011&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">FIGNERPRINT2</span> <span class="operator">=</span> <span class="string">&quot;zh-CN|24|1|4|1600_900|1600_860|-480|1|1|1|undefined|undefined|&quot;</span></span><br><span class="line">		+ <span class="string">&quot;unknown|Win64|unspecified|1|false|false|false|true|false|&quot;</span></span><br><span class="line">		+ <span class="string">&quot;0_true_true|d41d8cd98f00b204e9800998ecf8427F|b01de87fcefd32c68d348cd9d18b62d9&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">JQUERYSTR</span> <span class="operator">=</span> <span class="string">&quot;jQuery183025066063002634587_&quot;</span> + getNow();</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">initTime</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">Date</span>()).getTime();</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">TOKENCODE</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">TOKEN</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="解析Cookie"><a href="#解析Cookie" class="headerlink" title="解析Cookie"></a>解析Cookie</h4><p>这里实际写的时候遇到了坑点, 最初底层实现Cookie是参考<a href="https://stackoverflow.com/questions/5574530/how-to-parse-a-cookie-string">stackoverflow</a>中的那种实现<br>但是如果Cookie value中含有”&#x3D;”,解析就是失败，刚好58的session Cookie 中含有这个！！！我也是失败很多次才知道</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	protected CookieStore cookieStore = new BasicCookieStore();</span><br><span class="line"></span><br><span class="line">	public void setCookieStore(HttpResponse httpResponse) &#123;</span><br><span class="line"></span><br><span class="line">		Header[] headers = httpResponse.getHeaders(&quot;Set-Cookie&quot;);</span><br><span class="line">		if (headers != null &amp;&amp; headers.length &gt; 0) &#123;</span><br><span class="line">			for (int i = 0; i &lt; headers.length; i++) &#123;</span><br><span class="line">				String setCookie = headers[i].getValue();</span><br><span class="line">				try &#123;</span><br><span class="line">					BasicClientCookie cookie = this.parseRawCookie(setCookie);</span><br><span class="line">					if (!cookie.isExpired(new Date())) &#123;</span><br><span class="line">						this.cookieStore.addCookie(cookie);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					// do nothing</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this.cookieStore.clearExpired(new Date());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//使用java.net.HttpCookie自带的解析，然后手动转换成BasicClientCookie</span><br><span class="line">//这里java.net.HttpCookie会有些默认行为需要注意</span><br><span class="line">	protected BasicClientCookie parseRawCookie(String rawCookie) throws Exception &#123;</span><br><span class="line">		List&lt;HttpCookie&gt; cookies = HttpCookie.parse(rawCookie);</span><br><span class="line">		if (cookies.size() &lt; 1)</span><br><span class="line">			return null;</span><br><span class="line">		HttpCookie httpCookie = cookies.get(0);</span><br><span class="line">		BasicClientCookie cookie = new BasicClientCookie(httpCookie.getName(), httpCookie.getValue());</span><br><span class="line">		if (httpCookie.getMaxAge() &gt;= 0) &#123;</span><br><span class="line">			Date expiryDate = new Date(System.currentTimeMillis() + httpCookie.getMaxAge() * 1000);</span><br><span class="line">			cookie.setExpiryDate(expiryDate);</span><br><span class="line">		&#125;</span><br><span class="line">		if (httpCookie.getDomain() != null)</span><br><span class="line">			cookie.setDomain(httpCookie.getDomain());</span><br><span class="line">		if (httpCookie.getPath() != null)</span><br><span class="line">			cookie.setPath(httpCookie.getPath());</span><br><span class="line">		if (httpCookie.getComment() != null)</span><br><span class="line">			cookie.setComment(httpCookie.getComment());</span><br><span class="line">		cookie.setSecure(httpCookie.getSecure());</span><br><span class="line">		return cookie;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解析Response-String"><a href="#解析Response-String" class="headerlink" title="解析Response String"></a>解析Response String</h4><p>返回的Response类似于下面，需要提取其中的键值对</p>
<blockquote>
<p>jQuery18305434571389149673_1515995590691({“code”:0,”data”:{“remainTime”:0,”token”:”7pjUnv6fhBONHh7A_4HrN_2rH4is-gC8”,”rsaModulus”:”xxx固定值xxx”,<br>“rsaExponent”:”010001”,”totalTime”:60,”mobile”:”手机号”},”msg”:””})</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected String getResponseParameter(String response, String parameterName) &#123;</span><br><span class="line">	String result = response.replaceAll(&quot;,|\&quot;|:&quot;, &quot; &quot;);</span><br><span class="line">	StringTokenizer tokenizer = new StringTokenizer(result, &quot; &quot;);</span><br><span class="line">	while (tokenizer.hasMoreTokens() &amp;&amp; !tokenizer.nextToken().equals(parameterName)) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	String token = tokenizer.nextToken();</span><br><span class="line">	return token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发送Get请求模块"><a href="#发送Get请求模块" class="headerlink" title="发送Get请求模块"></a>发送Get请求模块</h4><p>因为后面很多都用到get 请求，所以这里封装一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">doGet</span><span class="params">(String url, String host)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="built_in">this</span>.createHttpClient();</span><br><span class="line">	<span class="type">HttpGet</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(url);</span><br><span class="line">	get.addHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>);</span><br><span class="line">	get.addHeader(<span class="string">&quot;accept&quot;</span>,</span><br><span class="line">			<span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;</span>);</span><br><span class="line">	get.addHeader(<span class="string">&quot;accept-encoding&quot;</span>, <span class="string">&quot;gzip, deflate, br&quot;</span>);</span><br><span class="line">	get.addHeader(<span class="string">&quot;accept-language&quot;</span>, <span class="string">&quot;en-US,en;q=0.9&quot;</span>);</span><br><span class="line">	get.addHeader(<span class="string">&quot;upgrade-insecure-requests&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">	get.addHeader(<span class="string">&quot;user-agent&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36&quot;</span>);</span><br><span class="line">	get.addHeader(<span class="string">&quot;Host&quot;</span>, host);</span><br><span class="line">	<span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.execute(get);</span><br><span class="line">	<span class="keyword">if</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;network error, unable to connect to 51job&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	setCookieStore(response);</span><br><span class="line">	<span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> entity.getContent();</span><br><span class="line">	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> IOUtils.toString(stream, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">	IOUtils.closeQuietly(stream);</span><br><span class="line">	EntityUtils.consumeQuietly(entity);</span><br><span class="line">	HttpClientUtils.closeQuietly(client);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加密字符串"><a href="#加密字符串" class="headerlink" title="加密字符串"></a>加密字符串</h4><p>QuanzhouJSUtil是一个调用js的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">encryptStr</span><span class="params">(String str)</span> &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">timeSpan</span> <span class="operator">=</span> <span class="number">1411093327735L</span>;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">randomLong</span> <span class="operator">=</span> timeSpan + (<span class="keyword">new</span> <span class="title class_">Date</span>()).getTime() - initTime;</span><br><span class="line">	<span class="type">String</span> <span class="variable">timeSign</span> <span class="operator">=</span> String.valueOf(randomLong);</span><br><span class="line">	<span class="type">String</span> <span class="variable">passwd</span> <span class="operator">=</span> timeSign + str;</span><br><span class="line">	<span class="type">String</span> <span class="variable">encryptPwd</span> <span class="operator">=</span> QuanzhouJSUtil.getEncryptString(passwd);</span><br><span class="line">	<span class="keyword">return</span> encryptPwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送动态码"><a href="#发送动态码" class="headerlink" title="发送动态码"></a>发送动态码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getPhoneCode(String phoneNumber) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	// 获得token,然后用token作为参数获取tokenCode, 然后发送验证码登录时候需要用到tokenCode和token</span><br><span class="line">	String result = doGet(FRONTEND_URL + getJQueryCallBackStr(), &quot;passport.58.com&quot;);</span><br><span class="line">	TOKEN = getResponseParameter(result, &quot;token&quot;);</span><br><span class="line"></span><br><span class="line">	// 获取token code</span><br><span class="line">	String enPhone = encryptStr(phoneNumber);</span><br><span class="line">	String tokenCodeURL = TOKENCODE_URL + &quot;mobile=&quot; + enPhone + &quot;&amp;validcode=&amp;source=pc-login&amp;vcodekey=&amp;token=&quot;</span><br><span class="line">			+ TOKEN + &quot;&amp;voicetype=0&amp;codetype=0&amp;fingerprint=&quot; + FINGERPRINT + &quot;&amp;&quot; + getJQueryCallBackStr() + &quot;&amp;path=&quot;</span><br><span class="line">			+ &quot;http://my.58.com&quot;;</span><br><span class="line">	result = doGet(tokenCodeURL, &quot;passport.58.com&quot;);</span><br><span class="line">	TOKENCODE = getResponseParameter(result, &quot;tokencode&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送动态码-1"><a href="#发送动态码-1" class="headerlink" title="发送动态码"></a>发送动态码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getPhoneCode(String phoneNumber) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	// 获得token,然后用token作为参数获取tokenCode, 然后发送验证码登录时候需要用到tokenCode和token</span><br><span class="line">	String result = doGet(FRONTEND_URL + getJQueryCallBackStr(), &quot;passport.58.com&quot;);</span><br><span class="line">	TOKEN = getResponseParameter(result, &quot;token&quot;);</span><br><span class="line"></span><br><span class="line">	// 获取token code</span><br><span class="line">	String enPhone = encryptStr(phoneNumber);</span><br><span class="line">	String tokenCodeURL = TOKENCODE_URL + &quot;mobile=&quot; + enPhone + &quot;&amp;validcode=&amp;source=pc-login&amp;vcodekey=&amp;token=&quot;</span><br><span class="line">			+ TOKEN + &quot;&amp;voicetype=0&amp;codetype=0&amp;fingerprint=&quot; + FINGERPRINT + &quot;&amp;&quot; + getJQueryCallBackStr() + &quot;&amp;path=&quot;</span><br><span class="line">			+ &quot;http://my.58.com&quot;;</span><br><span class="line">	result = doGet(tokenCodeURL, &quot;passport.58.com&quot;);</span><br><span class="line">	TOKENCODE = getResponseParameter(result, &quot;tokencode&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试登录"><a href="#测试登录" class="headerlink" title="测试登录"></a>测试登录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testLogin58()&#123;</span><br><span class="line">	preLogin();</span><br><span class="line">	String phoneNum = &quot;&quot;;</span><br><span class="line">	String mobileCode = &quot;&quot;;</span><br><span class="line">	System.out.println(&quot;请输入你的手机号码:&quot;);</span><br><span class="line">	Scanner scanner = new Scanner(System.in);</span><br><span class="line">	phoneNum = scanner.nextLine();</span><br><span class="line">	try &#123;</span><br><span class="line">		getPhoneCode(phoneNum);</span><br><span class="line">		System.out.println(&quot;请输入你的手机验证码:&quot;);</span><br><span class="line">		mobileCode = scanner.nextLine();</span><br><span class="line">		loginJob58(phoneNum, mobileCode);</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//add some code to do</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	scanner.close();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>BERT-of-Theseus</title>
    <url>/2023/08/08/BERT-of-Theseus/</url>
    <content><![CDATA[<h1 id="BERT-of-Theseus"><a href="#BERT-of-Theseus" class="headerlink" title="BERT-of-Theseus"></a>BERT-of-Theseus</h1><p>论文标题: BERT-of-Theseus: Compressing BERT by Progressive Module Replacing<br>作者: Canwen Xu, Wangchunshu Zhou, Tao Ge, Furu Wei, Ming Zhou<br>时间: 2020<br>核心算法名: BERT-of-Theseus<br>论文链接: <a href="https://arxiv.org/abs/2002.02925">https://arxiv.org/abs/2002.02925</a><br>参考: <a href="https://chat.openai.com/c/4b9f76af-42bc-47a4-90e6-cfe71e980e0c">科学空间</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着深度学习的普及，许多大型神经模型被提出并在各个领域取得了最先进的性能。特别是在自然语言处理（NLP）中，预训练和微调已经成为大多数任务的新规范。基于Transformer的预训练模型在自然语言理解（NLU）和自然语言生成（NLG）领域都占据了主导地位。这些模型受益于其“超参数化”的特性，并包含数百万甚至数十亿的参数，使其在计算成本和效率方面都显得过于昂贵和低效。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>为了解决这个问题，论文提出了一种新的模型压缩方法，通过逐步替换模块来有效地压缩BERT。该方法首先将原始的BERT划分为几个模块，并构建它们的紧凑替代品。然后，我们随机地用它们的替代品替换原始模块来训练紧凑模块以模仿原始模块的行为。我们逐渐增加替换的概率。这种方式使我们的方法在原始和紧凑模型之间带来了更深层次的交互。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>为了解决这个问题，已经提出了许多技术来压缩神经网络。一般来说，这些技术可以分为量化、权重剪枝和知识蒸馏。其中，知识蒸馏在压缩预训练语言模型方面受到了很多关注。知识蒸馏利用一个大的教师模型来“教”一个紧凑的学生模型来模仿教师的行为。这样，教师模型中的知识就可以被转移到较小的模型中。</p>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><p><img src="/media/16900523406602/16900523883902.jpg"></p>
<ol>
<li>将原始的BERT模型划分为几个模块，并为每个模块构建紧凑的替代品。<ul>
<li>1.1 随机地用它们的替代品替换原始模块来训练紧凑模块以模仿原始模块的行为。</li>
<li>1.2 逐渐增加替换的概率。</li>
</ul>
</li>
<li>在训练过程中，原始模型和紧凑模型一起工作，可能产生梯度级别的交互。不同的模块排列混合了前任和继任模块，可能增加了额外的正则化，类似于Dropout。</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li>与知识蒸馏相比，这种方法只使用了任务特定的损失函数。然而，基于知识蒸馏的方法使用任务特定的损失，以及一个或多个蒸馏损失作为其优化目标。</li>
<li>与最近的工作不同，Theseus Compression并没有使用Transformer特定的特性进行压缩，因此有可能压缩广泛的模型。</li>
<li>与知识蒸馏不同，这种方法允许原始模型与压缩后的继任模型一起工作，可能产生梯度级别的交互。此外，混合前任和继任模块的不同模块排列可能增加了额外的正则化，类似于Dropout。</li>
</ul>
<h2 id="对比效果"><a href="#对比效果" class="headerlink" title="对比效果"></a>对比效果</h2><ul>
<li>压缩后的BERT模型在保留原始模型超过98%的性能的同时，速度提高了1.94倍，超过了其他基于知识蒸馏的压缩基线。</li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>DNA序列</title>
    <url>/2016/05/11/DNA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>就是让你找这样一个字符串，让所给的串是目标串的子串，那么目标串最短应该是多少 （最多8个串，每个串长度最大为5）<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
</ul>
<ol>
<li><p>这个题我只用了迭代加深搜索，但是没剪枝过了，数据没卡我（AAAA GGGG CCCCC TTTTT就T了）。后面想了一下状态压缩记忆化搜索是可以在有限时间搜索出来的。用8个六进制的数字表示每一个串的当前位置。然后这个状态只有四种转移方向ATGC，然后从最终状态往前记忆化搜索就好了。</p>
</li>
<li><p>搜索一直没想出来怎么剪枝…,所以就使用迭代加深思想，然后暴力的枚举8个队列串首字符，比如枚举当前字符为A，那么谁队首是A的就POP出来，如果没有队首是A那就没必要搜索了。</p>
</li>
</ol>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>没啥坑点，就是不好好剪枝你会T在上面那个样例</p>
</li>
<li><p>在用状态压缩转移的时候，要用记忆化从最后搜，因为最初状态往后转移的话，初状态不好枚举。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: hh.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月10日 星期二 09时27分41秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> len[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> pos[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> ch[<span class="number">5</span>] = <span class="string">&quot;ATGC&quot;</span>;</span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> maxdepth, n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> *pp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth &gt; maxdepth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) p[i] = pp[i], sum+=len[i]-pp[i];</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            p[j] = pp[j];</span><br><span class="line">            <span class="keyword">while</span>(p[j] &lt; len[j] &amp;&amp; s[j][p[j]] == ch[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                p[j]++,sum++;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum) <span class="keyword">if</span>(<span class="built_in">dfs</span>(depth+<span class="number">1</span>, p))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        maxdepth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line">            len[i] = <span class="built_in">strlen</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(len[i] &gt; maxdepth) maxdepth = len[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; ; maxdepth++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) pos[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">0</span>,pos)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxdepth);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>状压 搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>ELECTRA (Stanford University &amp; Google Brain)</title>
    <url>/2023/08/08/ELECTRA%20(Stanford%20University%20&amp;%20Google%20Brain)/</url>
    <content><![CDATA[<h1 id="ELECTRA-Stanford-University-amp-Google-Brain"><a href="#ELECTRA-Stanford-University-amp-Google-Brain" class="headerlink" title="ELECTRA (Stanford University &amp; Google Brain)"></a>ELECTRA (Stanford University &amp; Google Brain)</h1><p>论文标题: ELECTRA: Pre-training Text Encoders as Discriminators Rather Than Generators, 作者: Kevin Clark, Minh-Thang Luong, Quoc V. Le, Christopher D. Manning, 时间: 2020, 核心算法名: ELECTRA, 论文链接: <a href="https://arxiv.org/abs/2003.10555">ELECTRA</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当前的语言表示学习方法可以被视为学习去噪自动编码器。他们选择未标记输入序列的一小部分（通常为15%），遮蔽这些token的身份（例如，BERT）或对这些token的注意力（例如，XLNet），然后训练网络恢复原始输入。虽然这些遮蔽语言建模（MLM）方法由于学习双向表示而比传统的语言模型预训练更有效，但它们通常需要大量的计算成本，因为网络每个示例只从15%的token中学习。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>作为替代，作者提出了一个更有效的预训练任务，称为替换token检测。与其遮蔽输入，作者的方法通过用从小型生成器网络采样的合理替代品替换一些token来破坏它。然后，作者训练了一个判别模型，该模型预测在被破坏的输入中的每个token是否被生成器样本替换。这种新的预训练任务比MLM更有效，因为该任务是在所有输入token上定义的，而不仅仅是被遮蔽的一小部分。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>ELECTRA的工作与BERT和XLNet有关，这两种方法都使用了遮蔽语言模型（MLM）进行预训练。然而，ELECTRA的方法与这些工作有所不同，因为它使用了替换token检测作为预训练任务，而不是MLM。</p>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><ol>
<li>ELECTRA训练两个神经网络，一个生成器G和一个判别器D。每个网络主要由一个将输入token序列映射到一系列上下文化向量表示的编码器（例如，Transformer网络）组成。</li>
<li>生成器被训练来执行遮蔽语言建模（MLM）。给定输入x，MLM首先选择一组随机位置来遮蔽，然后生成器学习预测被遮蔽token的原始身份。</li>
<li>判别器被训练来区分数据中的token和生成器替换的token。具体来说，我们创建一个被破坏的示例，通过用生成器样本替换被遮蔽的token，然后训练判别器预测在被破坏的输入中哪些token与原始输入匹配。</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li>与BERT和XLNet等MLM基础方法相比，给定相同的模型大小、数据和计算，ELECTRA在GLUE自然语言理解基准测试和SQuAD问题回答基准测试上的表现都有显著提高。</li>
<li>ELECTRA的方法在大规模应用时也表现良好，其性能与RoBERTa和XLNet相当，尽管其参数较少，使用的计算量不到他们的1&#x2F;4，并且在使用相同的计算量时超过了他们。</li>
<li>ELECTRA的方法在小模型上的收益尤为显著；例如，我们在一个GPU上训练了一个模型4天，该模型在GLUE自然语言理解基准测试上超过了GPT（使用30倍计算量训练的）。</li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Division</title>
    <url>/2016/06/07/Division/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>若点u可以到达点v,且点v可以也到达点u，那么u和v必须分在一组。<br>对于组内任意不相同两点u，v，必须保证u可以到达v或者v可以到达u。<br>你们的任务是求出最少可以分几个组<span id="more"></span></li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.首先tarjan缩点,得到一个无环图,然后再写最小路径覆盖</p>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第三场联合赛</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
        <tag>最小路径覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>Goozy搭积木</title>
    <url>/2016/05/23/Goozy%E6%90%AD%E7%A7%AF%E6%9C%A8/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li><p>goozy对积木十分的狂热，今天他想搭一个双子塔（就是两个高度一样的塔）！他想知道，用现有的积木，能不能实现这个想法.积木个数n(1 &lt;&#x3D; n &lt;&#x3D; 50)，每个积木的高度hi(1 &lt;&#x3D; hi &lt;&#x3D; 500000),题目保证所有积木高度总和不超过500000。</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
<li><p>建立状态</p>
<p>  这题和能不能把所有的平分是不一样的,因而我只要保证有一种方案把积木部分平分就好了</p>
<p>  所以建立状态不能用dp[i][j]表示i木块j高度是否可达</p>
<p>  状态是dp[i][j]表示前i个木块使得两份木块高度差为j的最大可达高度是多少.</p>
</li>
<li><p>状态转移</p>
</li>
</ul>
<pre><code>状态转移就很简单了,积木i放到比较高的那一方或者比较低的那一方
    
    放到比较高的一方
    
    dp[now][j+h] = max(dp[now][j+h],dp[1-now][j]+h);
    
    放到比较低的一方
    
    newh = max(dp[1-now][j]-j+h, dp[1-now][j]);
    
    dp[now][abs(h-j)] = max(dp[now][abs(h-j)], newh);
    
</code></pre>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>有时候dp建立状态后发现某一位范围过大,不能直接dp[i][j]的时候可以考虑特殊性质,然后对他们的差进行状态转移,正如D题一样</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: e.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月14日 星期六 03时07分49秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2</span>][<span class="number">250010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="comment">//	freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t, n, h;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">250010</span>; ++i) dp[<span class="number">0</span>][i] = dp[<span class="number">1</span>][i] = -INF;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">        dp[now][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h);</span><br><span class="line">            now = now^<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">250010</span>; ++j)&#123;</span><br><span class="line">                dp[now][j] = <span class="built_in">max</span>(dp[now][j], dp[<span class="number">1</span>-now][j]);</span><br><span class="line">                <span class="keyword">if</span>(dp[<span class="number">1</span>-now][j] &lt; j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(h&gt;=<span class="number">250010</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(j+h&lt;<span class="number">250010</span>) dp[now][j+h] = <span class="built_in">max</span>(dp[now][j+h],dp[<span class="number">1</span>-now][j]+h);</span><br><span class="line">                dp[now][<span class="built_in">abs</span>(h-j)] = <span class="built_in">max</span>(dp[now][<span class="built_in">abs</span>(h-j)], <span class="built_in">max</span>(dp[<span class="number">1</span>-now][j]-j+h, dp[<span class="number">1</span>-now][j]));</span><br><span class="line"><span class="comment">//                pr(abs(h-j));pr(h);pr(j);prln(dp[now][abs(h-j)]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = dp[now][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;GG\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第二场联合赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉</title>
    <url>/2016/06/07/Euler/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给你一个图,问你在有向图和无向图的情况下,是否存在欧拉通路</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.无向图情况下,欧拉通路存在充要条件是:所有点联通并且每个点的度必须是偶数,如果存在奇数度的点,那么这样的点必须有两个</p>
<p>2.有向图情况,存在欧拉图充要条件是:每个点初度必须等于入度,如果存在一个点出度比入度多一则必须还有一个点出度比入度小一</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.没啥坑点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: a.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">    &gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2016年05月28日 星期六 17时29分10秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span>  l[maxn], r[maxn];</span><br><span class="line"><span class="type">int</span> edgenum, head[maxn], to[maxn], nxt[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    nxt[edgenum] = head[u];</span><br><span class="line">    to[edgenum] = v;</span><br><span class="line">    head[u] = edgenum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="type">int</span> v = to[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t, n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">MEM</span>(l,<span class="number">0</span>);<span class="built_in">MEM</span>(r,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">MEM</span>(vis,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">MEM</span>(head,<span class="number">-1</span>);</span><br><span class="line">        edgenum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            l[a]++;r[b]++;</span><br><span class="line">            <span class="built_in">addedge</span>(a,b);</span><br><span class="line">            <span class="built_in">addedge</span>(b,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>, ok2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]) ok = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((l[i]+r[i])%<span class="number">2</span>) b++;</span><br><span class="line">            <span class="keyword">if</span>(l[i] == r[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(l[i]-r[i]) == <span class="number">1</span>) a++;</span><br><span class="line">            <span class="keyword">else</span> ok2 = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok&amp;&amp;b&lt;<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;Yes &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ok&amp;&amp;ok2&amp;&amp;a&lt;<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第三场联合赛</category>
      </categories>
      <tags>
        <tag>欧拉</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5723 Abandoned country (16多校第一场)</title>
    <url>/2016/08/06/HDU5723/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>给你一个图,让你求最小生成树,并且在最小生成树中求每条边被走的期望,<br>n个点m条边$( 1 \leq n \leq 10000, 1\leq m \leq 100000)$</p>
</blockquote>
<span id="more"></span>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>其实这题很水,只是我在补题的时候出现了一个致命bug,先是u &#x3D; find(u); v &#x3D; find(v);判断是不是一个块,如果是再加边,可是这里我至今addedge(u,v),u和v是祖先值已经改变了</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: aa.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   liangxianfeng96@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年07月22日 星期五 21时49分25秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) <span class="comment">//cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot;;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) <span class="comment">//cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt;  endl; </span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v, c;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Edge&amp;  rhs)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; rhs.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="type">int</span> head[maxn], nxt[maxn], to[maxn], cost[maxn];</span><br><span class="line"><span class="type">int</span> edgenum ;</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="type">int</span> p[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    edgenum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    nxt[edgenum] = head[u];</span><br><span class="line">    to[edgenum] = v;</span><br><span class="line">    cost[edgenum] = c;</span><br><span class="line">    head[u] = edgenum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] = (x==p[x]?x:<span class="built_in">find</span>(p[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = nxt[i])&#123;</span><br><span class="line">         <span class="type">int</span> v = to[i];</span><br><span class="line">         <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="built_in">dfs</span>(v);</span><br><span class="line">         siz[u] += siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> is[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edge, edge + m);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(is, <span class="number">0</span>, <span class="keyword">sizeof</span> is);</span><br><span class="line">    ll ans1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> u = edge[i].u;</span><br><span class="line">        <span class="type">int</span> v= edge[i].v;</span><br><span class="line">        <span class="built_in">pr</span>(u);<span class="built_in">prln</span>(v);</span><br><span class="line">        u = <span class="built_in">find</span>(u); v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(u == v) <span class="keyword">continue</span>;</span><br><span class="line">        p[u] = v;</span><br><span class="line">        is[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//pr(u);pr(v);prln(edge[i].c);</span></span><br><span class="line">        ans1 += edge[i].c;</span><br><span class="line">        <span class="built_in">addedge</span>(edge[i].u, edge[i].v, edge[i].c);</span><br><span class="line">        <span class="built_in">addedge</span>(edge[i].v, edge[i].u, edge[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is[i]) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="type">int</span> u = edge[i].u;</span><br><span class="line">         <span class="type">int</span> v= edge[i].v;</span><br><span class="line">         <span class="type">int</span> mi = <span class="built_in">min</span>(siz[u], siz[v]);</span><br><span class="line">        <span class="built_in">pr</span>(u);<span class="built_in">pr</span>(v);<span class="built_in">pr</span>(siz[u]);<span class="built_in">prln</span>(siz[v]);</span><br><span class="line">        <span class="built_in">prln</span>(mi);</span><br><span class="line">           ans += <span class="number">1.0</span>*(ll)(n-mi)*(ll)(mi)*(ll)edge[i].c/(<span class="number">1.0</span>*n*(n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ans2 = ans*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %.2f\n&quot;</span>, ans1, ans2);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> u, v, c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;c);</span><br><span class="line">            edge[i].u = u;</span><br><span class="line">            edge[i].v = v;</span><br><span class="line">            edge[i].c = c;</span><br><span class="line">            <span class="built_in">pr</span>(u);<span class="built_in">pr</span>(v);<span class="built_in">prln</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>最小生成树</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 5725 Game (16多校第一场)</title>
    <url>/2016/08/06/HDU5725/</url>
    <content><![CDATA[<p>$Time Limit:1000MS~~Memory Limit:65536KB $</p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>一个 $n \times m $的棋盘上有若干个守卫,每行每列至多只有一个守卫,现在问你除了守卫点,其他任意两点最短距离的期望. $ (2\leq n,m\leq 1000)$</p>
</blockquote>
<span id="more"></span>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>第一眼看只考虑到守卫会对每一行每一列的格子最短距离有影响,而忽略了下面这种情况</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 8</span><br><span class="line">########	###A####</span><br><span class="line">###G####	##CG####</span><br><span class="line">######G#	######GD</span><br><span class="line">####G###	####G###</span><br><span class="line">########	####B###</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如上A -&gt; B 以及C -&gt; D 也会被影响,所以这里还要考虑行的情况下列中G递增和递减对期望贡献的影响,列情况下也一样</p>
</li>
<li><p>还有就是写的时候可能写搓了就会T,这题987ms~780ms擦边过</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: cc.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">    &gt; Mail:   liangxianfeng96@qq.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2016年07月23日 星期六 14时39分42秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep_1(i,n) for(int i =1; i &lt;= n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) <span class="comment">//cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot;;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ii (n-i+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> jj (m-j+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) <span class="comment">//cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt;  endl; </span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll l[maxn][maxn], r[maxn][maxn], up[maxn][maxn], down[maxn][maxn];</span><br><span class="line"><span class="type">int</span> a[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">char</span> s[maxn][maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">        y = _y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;rr[maxn], cc[maxn];</span><br><span class="line"><span class="type">int</span> cntc, cntr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calcnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cntc = cntr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep_1</span>(i,n)&#123;</span><br><span class="line">        <span class="built_in">rep_1</span>(j,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;G&#x27;</span>)&#123; </span><br><span class="line">                a[i][j] = <span class="number">0</span>;</span><br><span class="line">                rr[cntr++] = <span class="built_in">Node</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> a[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep_1</span>(j, m)&#123;</span><br><span class="line">        <span class="built_in">rep_1</span>(i, n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)cc[cntc++] = <span class="built_in">Node</span>(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        l[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        l[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        r[i][m+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        r[i][m] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        up[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        up[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        down[n+<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        down[n][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep_1</span>(i, n)&#123;</span><br><span class="line">        <span class="built_in">rep_1</span>(j, m)&#123;</span><br><span class="line">            l[i][<span class="number">1</span>+j] = a[i][j] + l[i][j]; </span><br><span class="line">            up[i+<span class="number">1</span>][j] = a[i][j] + up[i][j];</span><br><span class="line">            down[ii<span class="number">-1</span>][jj] = a[ii][jj] + down[ii][jj];</span><br><span class="line">            r[ii][jj<span class="number">-1</span>] = a[ii][jj] + r[ii][jj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getremove1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y*(x+y)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">getremove</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ans = (ans + <span class="built_in">getremove1</span>(x<span class="number">-1</span>,y) + <span class="built_in">getremove1</span>(x,m-y) + <span class="built_in">getremove1</span>(n-x+<span class="number">1</span>,y<span class="number">-1</span>) + <span class="built_in">getremove1</span>(n-x,m-y+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getadd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans  = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    ll last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cntr; ++i)&#123;</span><br><span class="line">        Node&amp; g = rr[i];</span><br><span class="line">        ans += l[g.x][g.y]*r[g.x][g.y]*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            last = l[g.x][g.y];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(g.x-rr[i<span class="number">-1</span>].x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                last = l[g.x][g.y];</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; g.y &gt; rr[i<span class="number">-1</span>].y)&#123;</span><br><span class="line">                ans += last*r[g.x][g.y]*<span class="number">4</span>;</span><br><span class="line">                last += l[g.x][g.y];</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag &amp;&amp; g.y &lt; rr[i<span class="number">-1</span>].y)&#123;</span><br><span class="line">                last = r[rr[i<span class="number">-1</span>].x][rr[i<span class="number">-1</span>].y];</span><br><span class="line">                ans += last*l[g.x][g.y]*<span class="number">4</span>;</span><br><span class="line">                last += r[g.x][g.y];</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!flag &amp;&amp; g.y &gt; rr[i<span class="number">-1</span>].y)&#123;</span><br><span class="line">                last = l[rr[i<span class="number">-1</span>].x][rr[i<span class="number">-1</span>].y];</span><br><span class="line">                ans += last*r[g.x][g.y]*<span class="number">4</span>;</span><br><span class="line">                last += l[g.x][g.y];</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans += last*l[g.x][g.y]*<span class="number">4</span>;</span><br><span class="line">                last += r[g.x][g.y];</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag  = <span class="literal">true</span>;</span><br><span class="line">    last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cntc; ++i)&#123;</span><br><span class="line">        Node&amp; g = cc[i];</span><br><span class="line">        ans += up[g.x][g.y]*down[g.x][g.y]*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            last += up[g.x][g.y];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(g.y-cc[i<span class="number">-1</span>].y&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                last = up[g.x][g.y];</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; g.x &gt; cc[i<span class="number">-1</span>].x)&#123;</span><br><span class="line">                ans += last*down[g.x][g.y]*<span class="number">4</span>;</span><br><span class="line">                last += up[g.x][g.y];</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag &amp;&amp; g.x &lt; cc[i<span class="number">-1</span>].x)&#123;</span><br><span class="line">                last = down[cc[i<span class="number">-1</span>].x][cc[i<span class="number">-1</span>].y];</span><br><span class="line">                ans += last*up[g.x][g.y]*<span class="number">4</span>;</span><br><span class="line">                last += down[g.x][g.y];</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!flag &amp;&amp; g.x &gt; cc[i<span class="number">-1</span>].x)&#123;</span><br><span class="line">                last = up[cc[i<span class="number">-1</span>].x][cc[i<span class="number">-1</span>].y];</span><br><span class="line">                ans += last*down[g.x][g.y]*<span class="number">4</span>;</span><br><span class="line">                last += up[g.x][g.y];</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans += last*up[g.x][g.y]*<span class="number">4</span>;</span><br><span class="line">                last += down[g.x][g.y];</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">           </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">calcnt</span>();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll add = <span class="number">0</span>;</span><br><span class="line">    ll x = <span class="built_in">getremove</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    ll sumx = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        x -= (m<span class="number">-2</span>*i+<span class="number">2</span>)*n;</span><br><span class="line">        sumx += x;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = sumx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        sumx -= (n<span class="number">-2</span>*i+<span class="number">2</span>)*m*m;</span><br><span class="line">        sum += sumx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cntr; ++i)&#123;</span><br><span class="line">        sum -= <span class="number">2</span>*<span class="built_in">getremove</span>(rr[i].x, rr[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    add = <span class="built_in">getadd</span>();</span><br><span class="line">    ans = sum + add;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">rep_1</span>(i, n)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ll temp = <span class="built_in">solve</span>();</span><br><span class="line">        <span class="type">double</span> ans = (ll)n*m-cntc;</span><br><span class="line">        ans = ans*ans;</span><br><span class="line">        ll gadd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cntc; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cntc; ++j)&#123;</span><br><span class="line">                gadd += <span class="built_in">abs</span>(cc[i].x-cc[j].x)+<span class="built_in">abs</span>(cc[i].y-cc[j].y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp += gadd;</span><br><span class="line">        ans = temp*<span class="number">1.0</span>/ans;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>随笔</category>
        <category>乱搞</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 5729 Rigid Frameworks (16多校第一场)</title>
    <url>/2016/08/06/HDU5729/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>$给你一个n \times m(1\leq n,m \leq 10)的矩形,他由n \times m个单位矩阵组成$<br>$由于四边形具有不固定性,所以这个大矩形也是不固定的$<br>$现在让你加入一些斜着的边,问你多少种加的方案可以让他固定$</p>
</blockquote>
<span id="more"></span>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>最初我以为每行每列多加一个就可以把对应的行固定,可以这样想法太简单</li>
</ul>
<p><img src="/img/hdu5729a.jpg" alt="这样也是不固定的"></p>
<ul>
<li>这种思考的方式是错的,<br>&gt; - <strong>一个点固定一行是错的</strong><br>&gt; $这是在假设了除了当前行其他所有行都固定了$<br>&gt; $然后发现一行一个点就能固定$<br>&gt; $这错的,因为其他所有行都固定的情况下说明所有列也都被固定了,所有列固定了$<br>&gt; $所有行自然也是固定的$<br>&gt; - <strong>已知一个点固定了</strong>$假设和他相连的点也是固定的,然后推出都是固定的$<br>&gt; $如果不矛盾我就认为正确,这样推理假设方向反了,在这种情形下是不对的$</li>
<li>正确的思考方式是这样的<br>&gt; -    一个点不能滑动有两种情况$:1.自己本身不能滑动,2.别人限制你滑动$<br>&gt; $情况1不用讨论,现在讨论情况2.$<br>&gt; $假设所有点不符合情况1的都能滑动$<br>&gt; $那么如果假设与现实不矛盾或者如果能够找到一种滑动方案我就认为他能滑动$</li>
<li>上述思考方式对应的最基本的原型就是1*2的矩阵,一个被情况1固定,另一个不固定.这样属于符合上述假设所以能够滑动.</li>
</ul>
<p>   <img src="/img/hdu5729b.jpg" alt="2*2等效图,AD被固定"></p>
<pre><code>1\*2也许不容易思考.现在思考2\*2(同理衍生到3\*3等)的只有对角两个点被固定,他和上图中所给的情况是一样的,可以滑动,同时注意到n\*m的矩阵可以等效到2\*2上面,也就是左下角为确定固定的矩阵,右上角为确定固定矩阵,这时他们可以像2\*2一样滑动,为了阻止这种情况我们只需要在他们两个连接处任何一个位置添加一个就好因为这样就打破2\*2的滑动性,为了具有任意性也就是任意一个矩阵必须和他(等效后)斜对角矩形连通,进而转换成了**有多少种添加方式可以让某一个矩阵不被孤立**

孤立的条件是像2*2一样斜对角固定而两旁一个被固定的也没有-&gt;某一行某一列不能联通到其他所有行列-&gt;进而转换成连通图计数
    
</code></pre>
<ul>
<li><p>这道题也可以这样联想,我们要固定矩形的任何一个子矩形<br>&gt;1*1矩阵,固定他需要1个固定,1*2矩阵我们需要两个固定(且第二个放在新增加的行列上),2*2矩阵我们需要三个固定(且第三个放在新增加的行列上)…这样的模拟过程就是让新增的行列能够和之前联系也就是让所有行列连通</p>
</li>
<li><p>连通图计数<a href="http://blog.csdn.net/sdj222555/article/details/12453629">传送门</a></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: g.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">    &gt; Mail:   liangxianfeng96@qq.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2016年07月22日 星期五 12时38分39秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll c[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">ll base[<span class="number">110</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;c[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; ++i)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">            c[i][j] = (c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%MOD;</span><br><span class="line">            <span class="comment">//pr(i);pr(j);prln(c[i][j]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    base[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i)&#123;</span><br><span class="line">        base[i] = (base[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[<span class="number">11</span>][<span class="number">11</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>||j==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j][i+j<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= i*j; ++k)&#123;</span><br><span class="line">                dp[i][j][k] = c[i*j][k];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> ii = <span class="number">0</span>; ii &lt;= i; ++ii)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> jj = <span class="number">0</span>; jj &lt;= j; ++jj)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i+j==ii+jj) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> kk = <span class="number">0</span>; kk &lt;= k; ++kk)&#123;</span><br><span class="line">                            ll ret = c[i<span class="number">-1</span>][ii<span class="number">-1</span>]*c[j][jj]%MOD;</span><br><span class="line">                            ret = ret*dp[ii][jj][kk]%MOD;</span><br><span class="line">                            ret = ret*c[(i-ii)*(j-jj)][k-kk]%MOD;</span><br><span class="line">                            dp[i][j][k] = (dp[i][j][k]-ret+MOD)%MOD;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans = ans*x%MOD;</span><br><span class="line">        x = x*x%MOD;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">calc</span>();</span><br><span class="line">   <span class="built_in">slove</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n*m; ++i)&#123;</span><br><span class="line">            <span class="comment">//prln(i);</span></span><br><span class="line">            ans = (ans+base[i]*dp[n][m][i])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>图论</category>
        <category>连通图</category>
        <category>连通图计数</category>
      </categories>
      <tags>
        <tag>连通图计数</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5727 Necklace (16多校第一场)</title>
    <url>/2016/08/06/HDU5727/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>   $现在有2*N(1\leq n\leq 10)个珍珠,其中N个阳珍珠N个阴珍珠$<br>   $现在要求连接成一个项链必须阴阳间隔$<br>   $但是现在发现有些阳珍珠和特定的某些阴珍珠相连会变暗,问你至少有多少个阳珍珠变暗$<br>   $其中给你M(0\leq m\leq n ^2)对(x,y)表示阳珍珠x和阴珍珠y相连会会暗$</p>
</blockquote>
<span id="more"></span>


<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li><p>刚看这道题感觉无从下手,后面看了题解之后发现可以用迭代加深搜索来做,不过这样还是很麻烦</p>
<blockquote>
<p>   $这题可以逆向思考,至少有多少个变暗也就是至多有多少个不变暗$<br>   $怎样才不会变暗呢,当他左右两边都不会使他变暗$</p>
</blockquote>
</li>
<li><p>但想到这里还是不会做</p>
</li>
<li><p><strong>问题转换</strong></p>
</li>
</ul>
<blockquote>
<p>   $这里可以固定阴珍珠,让阳珍珠插到间隔位置中来$<br>   $这样的话,每个阳珍珠放入某个间隔中我们可以知道他会不会变暗$</p>
</blockquote>
<blockquote>
<p>   $而如上所说,现在可以转换为求至多能有多少不变暗$<br>   $分析到这里就转换成最大二分匹配$</p>
</blockquote>
<ul>
<li><p>这里可以用<code>do&#123;&#125;while(next_permutation(d, d+n-1));</code>很方便的求出1~n的全排列,需要注意的是最后一个间隙需要和第一个阴连接,所以判断的时候要多加一个</p>
</li>
<li><pre><code>丢一波学习二分图挺不错的[博客](http://www.renfei.org/blog/bipartite-matching.html)
</code></pre>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: e.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">    &gt; Mail:   liangxianfeng96@qq.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2016年07月20日 星期三 14时49分55秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>], b[<span class="number">100</span>], c[<span class="number">100</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Slove</span>&#123;</span><br><span class="line">    <span class="type">int</span> head[<span class="number">22</span>], nxt[<span class="number">210</span>], to[<span class="number">210</span>], edgenum;</span><br><span class="line">    <span class="type">int</span> check[<span class="number">22</span>];</span><br><span class="line">    <span class="type">int</span> match[<span class="number">22</span>];</span><br><span class="line">    <span class="type">int</span> left_num, right_num;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _n)</span></span>&#123;</span><br><span class="line">        n =_n;</span><br><span class="line">        left_num = right_num = n;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        edgenum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        nxt[edgenum] = head[u];</span><br><span class="line">        to[edgenum] = v;</span><br><span class="line">        head[u] = edgenum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = nxt[i])&#123;</span><br><span class="line">            <span class="type">int</span> v = to[i];</span><br><span class="line">            <span class="keyword">if</span>(!check[v])&#123;</span><br><span class="line">                check[v] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(match[v] == <span class="number">-1</span> || <span class="built_in">dfs</span>(match[v])) &#123;</span><br><span class="line">                    match[u] = v;</span><br><span class="line">                    match[v] = u;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(match, <span class="number">-1</span>, <span class="keyword">sizeof</span> match);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= left_num; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(match[i] == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">memset</span>(check, <span class="number">0</span>, <span class="keyword">sizeof</span> check);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;solve;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            vis[u][v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> d[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            solve.<span class="built_in">init</span>(n);</span><br><span class="line">            <span class="type">int</span> temp = d[n];</span><br><span class="line">            d[n] = d[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)      &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                    <span class="type">int</span> x = d[j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(!vis[i][x] &amp;&amp; !vis[i][d[j]])&#123;</span><br><span class="line">                        <span class="comment">//pr(i);prln(x);</span></span><br><span class="line">                        solve.<span class="built_in">addedge</span>(i, x+n);</span><br><span class="line">                        solve.<span class="built_in">addedge</span>(x+n, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            d[n] = temp;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, solve.<span class="built_in">hungry</span>());</span><br><span class="line">            <span class="comment">//prln(ans);</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(d, d+n<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n-ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>二分匹配</category>
      </categories>
      <tags>
        <tag>二分匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5728 PowMod (16多校第一场)</title>
    <url>/2016/08/06/HDU5728/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>$k&#x3D;\sum_{i&#x3D;1}^{m} \varphi (i*n)\ mod\ 1000000007$<br>$n$ is a square-free number. 一个无平方因子数,质因子的指数是1<br>$\varphi $ is the Euler’s totient function. </p>
<p>find: $ans&#x3D;k^{k^{k^{k^{…^k}}}}\ mod \ p$ </p>
</blockquote>
<span id="more"></span>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li><p>这题看<a href="http://blog.csdn.net/wust_zzwh/article/details/51966450">题解</a>看了老半天<br>&gt; - <strong>第一步</strong><br>   计算每一个$p _j$对n的贡献得出:$f(n,m)&#x3D;ϕ(pj)∗f(\frac n{p _j},m)+f(n,\frac m {p _j})$    </p>
<blockquote>
<ul>
<li><strong>第二步</strong><br> 利用上面公式不断递归得出k的值,递归终点是f(1,y)或者f(x,1)以及f(x,0);</li>
<li><strong>第三步</strong><br>  利用公式$a ^b %p&#x3D;a ^{b % ϕ(p)+ϕ(p) }%p$,一直递归到p&#x3D;0</li>
</ul>
</blockquote>
</li>
<li><p>附送线性筛法<a href="http://blog.csdn.net/Lytning/article/details/24432651">传送门</a></p>
</li>
<li><p>欧拉函数是<a href="http://baike.baidu.com/view/2046973.htm">积性函数</a>,给出一些欧拉函数性质<br>-    设a为N的质因数<br>若**(N%a &#x3D;&#x3D; 0 &amp;&amp; (N &#x2F; a) % a &#x3D;&#x3D; 0)**<br>则有<strong>E(N)&#x3D;E(N &#x2F; a) * a</strong><br>若**(N % a &#x3D;&#x3D; 0 &amp;&amp; (N &#x2F; a) % a !&#x3D; 0) **<br>则有：<strong>E(N) &#x3D; E(N &#x2F; a) * (a - 1)</strong><br>- 当n为奇数时，φ(2n)&#x3D;φ(n)<br>- 若n是质数p的k次幂<br>   <strong>φ(n)&#x3D;p^k-p^(k-1)&#x3D;(p-1)p^(k-1)</strong><br>   因为除了p的倍数外，其他数都跟n互质。<br>- 若m,n互质<br>   <strong>φ(mn)&#x3D;φ(m)φ(n)</strong></p>
</li>
<li><p>欧拉定理：对于互质的正整数a和n，有aφ(n) ≡ 1 mod n。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: f.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">    &gt; Mail:   liangxianfeng96@qq.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2016年07月22日 星期五 15时04分33秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e7</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> phi[maxn], prime[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> pt;</span><br><span class="line">ll sum[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    pt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            phi[i] = i<span class="number">-1</span>;</span><br><span class="line">            prime[pt++] = i;</span><br><span class="line">            <span class="comment">//prln(i);</span></span><br><span class="line">            <span class="comment">//if(i&gt;100) break;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; pt ; ++j)&#123;</span><br><span class="line">            k = prime[j]*i;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=maxn) <span class="keyword">break</span>;</span><br><span class="line">            vis[k] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                phi[k] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                phi[k] = phi[i] * (prime[j]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i)&#123;</span><br><span class="line">        sum[i] = (sum[i<span class="number">-1</span>] + phi[i])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getans</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> sum[m];</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span>) <span class="keyword">return</span> phi[n];</span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pt; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ((prime[i]<span class="number">-1</span>)*<span class="built_in">getans</span>(n/prime[i], m)%MOD + <span class="built_in">getans</span>(n, m/prime[i]))%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ret</span><span class="params">(ll x, ll y, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    x%=p;</span><br><span class="line">    <span class="comment">//prln(p);</span></span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans = ans*x%p;</span><br><span class="line">        <span class="comment">//pr(x);pr(y);pr(ans);prln(MOD);</span></span><br><span class="line">        x = x*x%p;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getpow</span><span class="params">(ll k, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll tmp = <span class="built_in">getpow</span>(k, phi[p]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ret</span>(k, tmp+phi[p], p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n, m, p;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p) != EOF)&#123;</span><br><span class="line">        ll k = <span class="built_in">getans</span>(n,m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">getpow</span>(k,p));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学</category>
        <category>欧拉</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5726 GCD (16多校第一场)</title>
    <url>/2016/08/06/HDU5726/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>$给你一个长度为n(1\leq n \leq 100000)序列:a _1,a _2, a_3…(1 \leq a _i \leq 10 ^9 )$<br>$现在给你q个查询,每个查询问你存在多少个区间gcd的值等于区间[l,r]区间的gcd值$</p>
</blockquote>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>第一步使用倍增可以很快求出区间[l,r]的gcd的值</li>
<li><strong>如何很快的统计</strong>有多少个区间的gcd值等于x?</li>
</ul>
<blockquote>
<p>   $这里需要认识到一个性质,以某一个数字开始往后gcd的值只会减少不会增加,因而最多有log _2 x$<br>   $所以这里我们可以记录以某一个位置开始或结束所有区间gcd的状态即可$<br>   $eg: dp[i]记录以位置i结尾所有区间gcd的值以及个数$<br>    $则有dp[i+1]&#x3D;dp[i]+gcd(dp[i],a[i+1])$</p>
</blockquote>
<p>刚开始以为不能用map,后面直接map过了,使用map映射转移的话复杂度是nlog$ ^2 n $</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: d.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   liangxianfeng96@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年07月19日 星期二 17时52分44秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> HASHSIZE = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">gcd</span>(y, x%y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[l]);</span><br><span class="line">        sum[rt] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(rt&lt;&lt;<span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">build</span>(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, m+<span class="number">1</span>, r);</span><br><span class="line">    sum[rt] = <span class="built_in">gcd</span>(sum[rt&lt;&lt;<span class="number">1</span>], sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(qr &lt;= m) <span class="keyword">return</span> <span class="built_in">query</span>(rt&lt;&lt;<span class="number">1</span>, l, m, ql, qr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ql &gt; m) <span class="keyword">return</span> <span class="built_in">query</span>(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, m+<span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(<span class="built_in">query</span>(rt&lt;&lt;<span class="number">1</span>, l, m, ql, qr), <span class="built_in">query</span>(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, m+<span class="number">1</span>, r, ql, qr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l[maxn], r[maxn];</span><br><span class="line"><span class="type">int</span> num[maxn], ans[maxn];</span><br><span class="line">map&lt;<span class="type">int</span>, ll&gt; ha, mp[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">20</span>][<span class="number">123456</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="type">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;i)&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">gcd</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">getlen</span>(y-x+<span class="number">1</span>) <span class="number">-1</span>;</span><br><span class="line">            num[i] = <span class="built_in">gcd</span>(dp[len][x], dp[len][y-(<span class="number">1</span>&lt;&lt;len)+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">        mp[<span class="number">0</span>].<span class="built_in">clear</span>();</span><br><span class="line">        mp[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">        ha.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(now,pre);</span><br><span class="line">            mp[now].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> itr = mp[pre].<span class="built_in">begin</span>(); itr != mp[pre].<span class="built_in">end</span>(); itr++)&#123;</span><br><span class="line">               <span class="type">int</span> temp = <span class="built_in">gcd</span>(dp[<span class="number">0</span>][i], itr-&gt;first);</span><br><span class="line">               mp[now][temp] += itr-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[now][dp[<span class="number">0</span>][i]]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> itr = mp[now].<span class="built_in">begin</span>(); itr != mp[now].<span class="built_in">end</span>(); itr++)&#123;</span><br><span class="line">                ha[itr-&gt;first] += itr-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,++kase);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="comment">//prln(num[i]);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %lld\n&quot;</span>, num[i], ha[num[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>随笔</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>NightMare2</title>
    <url>/2016/06/07/NightMare2/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>现在路人甲要在规定时间逃出迷宫,同时他还想尽可能的把当前无穷多的宝藏带出去,但是每条路径规定至多只能带多少宝藏,问你他在规定时间最多带出多少宝藏<span id="more"></span></li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.这题我们可以二分宝藏值,看在带出宝藏x的情况下能不能在有限时间走出去,这里把财富值小于x的边给禁止了就好</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.二分的时候一定要记得尽可能去右面的值也就是m &#x3D; (l+r+1)&gt;&gt;1</p>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第三场联合赛</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Map Net-北大</title>
    <url>/2023/08/08/Map%20Net-%E5%8C%97%E5%A4%A7/</url>
    <content><![CDATA[<h1 id="Map-Net-北大"><a href="#Map-Net-北大" class="headerlink" title="Map Net-北大"></a>Map Net-北大</h1><h1 id="Variance-reduced-Language-Pretraining-via-a-Mask-Proposal-Network"><a href="#Variance-reduced-Language-Pretraining-via-a-Mask-Proposal-Network" class="headerlink" title="Variance-reduced Language Pretraining via a Mask Proposal Network"></a>Variance-reduced Language Pretraining via a Mask Proposal Network</h1><p>这篇论文的标题是”Variance-reduced Language Pretraining via a Mask Proposal Network”，作者是Liang Chen，发表于2020年。</p>
<h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>自我监督学习，也称为预训练，对自然语言处理非常重要。大多数预训练方法首先随机掩盖句子中的一些位置，然后训练模型恢复被掩盖位置的标记。这样，模型可以在没有人工标注的情况下进行训练，并且可以使用大量的数据和数十亿的参数。因此，优化效率变得至关重要。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>本文从梯度方差降低的角度解决这个问题。特别是，首先提出了一个原则性的梯度方差分解定理，该定理显示，语言预训练的随机梯度的方差可以自然地分解为两个项：一项是来自批处理中数据样本的方差，另一项是来自掩码采样的方差。为了减少第二部分的方差，我们利用重要性采样策略，该策略旨在根据提议分布而不是均匀分布来采样掩码。</p>
<span id="more"></span>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><p>为了提高效率，我们引入了一个掩码提议网络（MAP-Net），该网络近似最优的掩码提议分布，并且与模型一起进行端到端的训练。根据实验结果，我们的模型比基线BERT模型收敛得更快，性能也更高。</p>
<h2 id="相关工作："><a href="#相关工作：" class="headerlink" title="相关工作："></a>相关工作：</h2><p>在自然语言处理中，预训练的上下文表示已被广泛用于帮助缺乏足够标签训练数据的下游任务。之前的工作开发了各种自我监督任务来获取预训练的上下文表示。例如，BERT首先随机选择句子中的少数位置，掩盖这些位置上的单词，然后学习一个编码器来恢复它们。由于这样的任务不需要人类监督，所以可用的训练数据的规模可以轻易地达到数十亿个单词的规模。在这样大规模的数据上进行预训练需要消耗大量的计算资源。</p>
<h2 id="对比效果："><a href="#对比效果：" class="headerlink" title="对比效果："></a>对比效果：</h2><p>我们使用MAP-Net来帮助BERT的训练，并在GLUE自然语言理解基准上评估它们。实验结果首先表明，MAP-NET在训练过程中生成的掩码词是有意义的，并且在训练过程中提供了信息。此外，由于方差被充分降低，使用MAP-Net训练的BERT模型在大多数任务上比基线模型具有更好的准确性。</p>
<h2 id="主要差异："><a href="#主要差异：" class="headerlink" title="主要差异："></a>主要差异：</h2><p>本文的主要贡献是提出了一种新的方差降低算法，用于更好的语言预训练。特别是，我们观察到所有以前的工作在构建自我监督任务时都使用均匀采样的位置进行掩码，而这从优化的角度来看是不可避免的低效的。例如，在BERT训练中，我们发现常用的单词和标点符号易于学习，即这些单词（如果被掩盖）可以在几千个训练步骤中被模型正确预测。同时，一些罕见的单词和短语即使在训练结束时也难以预测。如果我们总是均匀地采样掩码的位置，直观地说，随机梯度（相对于掩码的随机性）的方差可能会很大，因为一些位置逐渐提供的信息信号较少，而一些位置则没有。通常，使用大方差的梯度估计器进行学习将是低效和无效的。</p>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Performer - Google</title>
    <url>/2023/08/08/Performer%20-%20Google%20&amp;%20University%20of%20Cambridge/</url>
    <content><![CDATA[<h1 id="Performer-Google-amp-University-of-Cambridge"><a href="#Performer-Google-amp-University-of-Cambridge" class="headerlink" title="Performer - Google &amp; University of Cambridge"></a>Performer - Google &amp; University of Cambridge</h1><p>论文标题：Rethinking Attention with Performers<br>作者：Krzysztof Choromanski, Valerii Likhosherstov, David Dohan, Xingyou Song, Andreea Gane, Tamas Sarlos, Peter Hawkins, Jared Davis, Afroz Mohiuddin, Lukasz Kaiser, David Belanger, Lucy Colwell, Adrian Weller<br>时间：2021<br>核心算法名：Performer<br>论文链接：<a href="https://arxiv.org/abs/2009.14794">arXiv:2009.14794v4</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Transformer架构在机器学习的多个领域中都取得了最先进的结果，包括自然语言处理、神经机器翻译、文档生成&#x2F;摘要、时间序列预测、生成建模（如图像生成）、音乐生成和生物信息学等。然而，Transformer的计算复杂度随着输入序列的长度呈二次增长，这对于处理大规模序列的任务来说是不可接受的。为了解决这个问题，研究者们提出了多种方法，如限制注意力机制只关注局部邻域，或者引入稀疏性、池化压缩、聚类&#x2F;分箱&#x2F;卷积技术等结构先验。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>Performer是一种新的Transformer架构，它能够以可证明的准确性估计常规（softmax）全秩注意力Transformer，但只使用线性（而不是二次）的空间和时间复杂度，而且不依赖于任何先验知识，如稀疏性或低秩性。为了近似softmax注意力核，Performer使用了一种新的通过正交随机特征进行快速注意力（FAVOR+）的方法，这可能对可扩展的核方法具有独立的兴趣。FAVOR+还可以用于有效地模拟超出softmax的可核化注意力机制。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>Transformer架构在机器学习的多个领域中都取得了最先进的结果，包括自然语言处理、神经机器翻译、文档生成&#x2F;摘要、时间序列预测、生成建模（如图像生成）、音乐生成和生物信息学等。然而，Transformer的计算复杂度随着输入序列的长度呈二次增长，这对于处理大规模序列的任务来说是不可接受的。为了解决这个问题，研究者们提出了多种方法，如限制注意力机制只关注局部邻域，或者引入稀疏性、池化压缩、聚类&#x2F;分箱&#x2F;卷积技术等结构先验。</p>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> \begin&#123;equation&#125;\begin&#123;aligned&#125; </span><br><span class="line">e^&#123;\boldsymbol&#123;q&#125;\cdot \boldsymbol&#123;k&#125;&#125;&amp;=\mathbb&#123;E&#125;_&#123;\boldsymbol&#123;\omega&#125;\sim \mathcal&#123;N&#125;(\boldsymbol&#123;\omega&#125;;0,\boldsymbol&#123;1&#125;_d)&#125;\left[e^&#123;\boldsymbol&#123;\omega&#125;\cdot \boldsymbol&#123;q&#125;-\Vert \boldsymbol&#123;q&#125;\Vert^2 / 2&#125; \times e^&#123;\boldsymbol&#123;\omega&#125;\cdot \boldsymbol&#123;k&#125;-\Vert \boldsymbol&#123;k&#125;\Vert^2 / 2&#125;\right]\\[6pt] </span><br><span class="line">&amp;\approx\underbrace&#123;\frac&#123;1&#125;&#123;\sqrt&#123;m&#125;&#125;\begin&#123;pmatrix&#125;e^&#123;\boldsymbol&#123;\omega&#125;_1\cdot \boldsymbol&#123;q&#125;-\Vert \boldsymbol&#123;q&#125;\Vert^2 / 2&#125; \\ </span><br><span class="line">e^&#123;\boldsymbol&#123;\omega&#125;_2\cdot \boldsymbol&#123;q&#125;-\Vert \boldsymbol&#123;q&#125;\Vert^2 / 2&#125;\\ </span><br><span class="line">\vdots\\ </span><br><span class="line">e^&#123;\boldsymbol&#123;\omega&#125;_m\cdot \boldsymbol&#123;q&#125;-\Vert \boldsymbol&#123;q&#125;\Vert^2 / 2&#125; \end&#123;pmatrix&#125;&#125;_&#123;\tilde&#123;\boldsymbol&#123;q&#125;&#125;&#125; </span><br><span class="line">\cdot  \underbrace&#123;\frac&#123;1&#125;&#123;\sqrt&#123;m&#125;&#125;\begin&#123;pmatrix&#125;e^&#123;\boldsymbol&#123;\omega&#125;_1\cdot \boldsymbol&#123;k&#125;-\Vert \boldsymbol&#123;k&#125;\Vert^2 / 2&#125; \\ </span><br><span class="line">e^&#123;\boldsymbol&#123;\omega&#125;_2\cdot \boldsymbol&#123;k&#125;-\Vert \boldsymbol&#123;k&#125;\Vert^2 / 2&#125;\\ </span><br><span class="line">\vdots\\ </span><br><span class="line">e^&#123;\boldsymbol&#123;\omega&#125;_m\cdot \boldsymbol&#123;k&#125;-\Vert \boldsymbol&#123;k&#125;\Vert^2 / 2&#125; \end&#123;pmatrix&#125;&#125;_&#123;\tilde&#123;\boldsymbol&#123;k&#125;&#125;&#125; </span><br><span class="line">\end&#123;aligned&#125;\label&#123;eq:core&#125;\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<p>我们就可以将原来head_size为d<br>的标准Attention，转化为head_size为m<br>的线性Attention了，这便是整篇论文的核心思路。</p>
<p>重点在于线性的attention的话, 就可以优化矩阵乘法了<br>原本是 $ (QK)V $复杂度n^2d, 变成线性之后, 为 $ Q(KV) $复杂度nd+nm, 但是这里m的采样一般需要高于d</p>
<ol>
<li>Performer使用FAVOR+机制来估计注意力矩阵。FAVOR+使用正交随机特征来近似softmax注意力核，这可能对可扩展的核方法具有独立的兴趣。FAVOR+还可以用于有效地模拟超出softmax的可核化注意力机制。</li>
<li>Performer是第一种完全兼容常规Transformer的线性架构，提供了强大的理论保证：无偏或近乎无偏的注意力矩阵估计，一致性收敛和低估计方差。</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li>Performer与其他工作的主要区别在于，它能够以可证明的准确性估计常规（softmax）全秩注意力Transformer，但只使用线性（而不是二次）的空间和时间复杂度，而且不依赖于任何先验知识，如稀疏性或低秩性。</li>
<li>在像素预测、文本模型和蛋白质序列建模等丰富的任务集上测试Performer，我们展示了与其他检查的有效稀疏和密集注意力方法的竞争结果，展示了Performer利用的新注意力学习范式的有效性。</li>
</ul>
<p><img src="/media/16900557870014/16900563504645.jpg"></p>
<p><img src="/media/16900557870014/16900563595898.jpg"></p>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型 Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear Attention</title>
    <url>/2023/08/08/Linear%20Attention/</url>
    <content><![CDATA[<h1 id="Linear-Attention"><a href="#Linear-Attention" class="headerlink" title="Linear Attention"></a>Linear Attention</h1><p>链接：<a href="https://spaces.ac.cn/archives/7546">https://spaces.ac.cn/archives/7546</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Attention机制在自然语言处理（NLP）和计算机视觉（CV）中得到了广泛的应用。然而，标准的Attention机制的计算复杂度为O(n^2)，这在处理长序列时会带来问题。因此，研究者们提出了各种方法来降低Attention的计算复杂度，包括稀疏Attention、Reformer、Linformer等。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>本文主要探讨了如何通过去掉Softmax来实现线性Attention，即将Attention的计算复杂度降低到O(n)。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul>
<li><p>稀疏Attention：通过限制每个token只能关注到固定数量的其他token，从而降低Attention的计算复杂度。</p>
</li>
<li><p>Reformer：通过使用Locality-Sensitive Hashing (LSH) 和可逆网络来降低显存占用量。而是通过LSH（Locality Sensitive Hashing）技术（近似地）快速地找到最大的若干个Attention值，然后只去计算那若干个值。</p>
</li>
<li><p>Linformer：通过在进行Attention之前，用两个矩阵对K和V进行投影，从而降低Attention的计算复杂度。<br><img src="/media/16900528123303/16900541407020.jpg"></p>
</li>
</ul>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><ol>
<li>替换相似函数，将原来的权重e^{q_i^T k_j}替换为sim(q_i, k_j)，其中sim(q_i, k_j)是q_i和k_j的一般函数，要求sim(q_i, k_j) &gt;&#x3D; 0。<ul>
<li>1.1 为了保留Attention相似的分布特性，我们要求sim(q_i, k_j) &gt;&#x3D; 0。</li>
</ul>
</li>
<li>替换softmax，通过去掉Softmax，将原来的q @ (k @ v)改为(q @ k) @ v，从而将Attention的计算复杂度降低到O(n)。</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li>与稀疏Attention和Reformer相比，本文的方法更简单，不需要复杂的实现。</li>
<li>与Linformer相比，本文的方法可以做到Causal Masking，因此可以用于语言模型、Seq2Seq等自回归生成任务。</li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型 Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>RunningPhoton&#39;s Nightmare</title>
    <url>/2016/05/11/RunningPhoton&#39;sNightmare/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>一个人站在S这个起始位置，想要走到一个迷宫出口E，但是现在这个人身上有一个炸弹在k时间内就会爆炸，同时到达一些R位置能够让炸弹计时器清零，问能否出迷宫，能并输出最短时间,其中迷宫大小不超过600*600，1&lt;&#x3D;k&lt;&#x3D;600，最多有100个清零器</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.在S起点距离k的位置内的所有的都是可达并且最优时间等于最短距离。然后再由这些已经确定是最短的并且炸弹时间已被清零的点来更新周围距离k的点（如果炸弹时间不清零，那么这个点所能够到达的最远距离只能够在S的范围之内…）,然后这就好比是dijstra算法，只是多了一个限制（只能由R点更新周围点）。</p>
<p>2.刚开始拿到这一题想的是从起点开始暴搜（受到华为那个寻路比赛影响），状态包含当前已经走过的时间和炸弹剩余的时间以及当前位置，但是这样的话什么样的状态才是最优的就不好确定了，如果k小的话倒是能够对每个位置的每一个炸弹时间k记录一个最优时间。但是k比较大…</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.上述算法最终只有S，E，R这三个点起作用了，那么现在就只看这三个点。如果这三类点距离小于k那么表示可以联通，也就是在原图的基础上面重新建了一个图。那就无脑跑100多次bfs求最短路，如果三类点距离d小于k则他们建一个d距离的边否则不能直接相连。</p>
<p>2.为了代码美观好写，用bfs求最短路的时候传入距离数组指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: e.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月04日 星期三 16时10分44秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">char</span> mp[<span class="number">610</span>][<span class="number">610</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Node&amp; rhs)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x== rhs.x&amp;&amp;y==rhs.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y)&#123;</span><br><span class="line">        x = _x; y = _y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> k, n, m;</span><br><span class="line">Node node[<span class="number">155</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">660</span>][<span class="number">660</span>], d[<span class="number">160</span>][<span class="number">160</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">            dis[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(node[id]);</span><br><span class="line">    dis[node[id].y][node[id].x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        Node u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> nx = u.x + dx[i];</span><br><span class="line">            <span class="type">int</span> ny = u.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= m || ny &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp[ny][nx] == <span class="string">&#x27;W&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[ny][nx] &gt; dis[u.y][u.x] + <span class="number">1</span>)&#123;</span><br><span class="line">                dis[ny][nx] = dis[u.y][u.x] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(nx,ny));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[node[i].y][node[i].x] &gt;= k) d[id][i] = INF;</span><br><span class="line">        <span class="keyword">else</span> d[id][i] = dis[node[i].y][node[i].x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="type">int</span> src, des;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j] == <span class="string">&#x27;S&#x27;</span>) src = cnt;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j] == <span class="string">&#x27;E&#x27;</span>) des = cnt;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j] != <span class="string">&#x27;W&#x27;</span> &amp;&amp; mp[i][j] != <span class="string">&#x27;.&#x27;</span>) node[cnt++] = <span class="built_in">Node</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) <span class="built_in">bfs</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cnt; ++k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(d[i][k] + d[k][j] &lt;= d[i][j]) d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d[src][des] &lt; INF) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[src][des]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Poor RunningPhoton!\n&quot;</span> );</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>RealFormer-谷歌</title>
    <url>/2023/08/08/RealFormer-%E8%B0%B7%E6%AD%8C/</url>
    <content><![CDATA[<h1 id="RealFormer-谷歌"><a href="#RealFormer-谷歌" class="headerlink" title="RealFormer-谷歌"></a>RealFormer-谷歌</h1><p>论文标题: RealFormer: Transformer Likes Residual Attention, 作者: Ruining He, Anirudh Ravula, Bhargav Kanagal, Joshua Ainslie, 时间: 2021年9月10日, 核心算法名: RealFormer, 论文链接: <a href="https://arxiv.org/abs/2012.11747">arXiv:2012.11747</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Transformer是现代自然语言处理（NLP）模型的基础。然而，尽管Transformer在许多任务中表现出色，但其设计和实现仍有改进的空间。本文提出了一种名为RealFormer的新技术，该技术通过在Transformer网络中创建残差注意层（Residual Attention Layer）来改进Transformer的性能。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>RealFormer的目标是改进Transformer网络的性能，使其在各种任务中表现更好。这些任务包括Masked Language Modeling、GLUE、SQuAD、Neural Machine Translation、WikiHop、HotpotQA、Natural Questions和OpenKP等。此外，RealFormer还旨在稳定训练过程，并使模型的注意力更加稀疏。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>Transformer最初由Vaswani等人在2017年提出，用于神经机器翻译（NMT），并从此深刻改变了NLP领域。此后，许多工作都在探索如何改进Transformer，包括提出更好的自我监督目标、使用更大的预训练数据和更好的超参数、模型参数共享、多任务预训练等。这些工作通常采用Post-LN Transformer作为其核心。在本文中，我们采用BERT来测试不同的Transformer架构，因为它被广泛使用并具有代表性。</p>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><p><img src="/media/16900574891714/16900575043063.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">Attention(\boldsymbol&#123;Q&#125;_n,\boldsymbol&#123;K&#125;_n,\boldsymbol&#123;V&#125;_n) = softmax\left(\boldsymbol&#123;A&#125;_n\right)\boldsymbol&#123;V&#125;_n,\quad \boldsymbol&#123;A&#125;_n=\frac&#123;\boldsymbol&#123;Q&#125;_n\boldsymbol&#123;K&#125;_n^&#123;\top&#125;&#125;&#123;\sqrt&#123;d_k&#125;&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<p>变成如下形式:a</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">Attention(\boldsymbol&#123;Q&#125;_n,\boldsymbol&#123;K&#125;_n,\boldsymbol&#123;V&#125;_n) = softmax\left(\boldsymbol&#123;A&#125;_n\right)\boldsymbol&#123;V&#125;_n,\quad \boldsymbol&#123;A&#125;_n=\frac&#123;\boldsymbol&#123;Q&#125;_n\boldsymbol&#123;K&#125;_n^&#123;\top&#125;&#125;&#123;\sqrt&#123;d_k&#125;&#125; + \boldsymbol&#123;A&#125;_&#123;n-1&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>RealFormer的核心是在Transformer网络中创建一个“直接”路径，以传播原始注意力分数。这通过在每个RealFormer层中添加“残差分数”（以与常规Transformer中的注意力分数相同的方式计算）来实现。然后，这两个分数的和被用来通过softmax计算注意力概率。</li>
<li>实际上，RealFormer可以被看作是在基础Transformer上添加了简单的跳过连接。由于它不添加昂贵的乘法操作，因此预期性能将是可比较的。注意，我们的技术也可以直接应用于不同的Transformer变体。</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li>RealFormer与其他工作的主要区别在于，它通过创建残差注意层来改进Transformer网络，这是一种新颖的方法。</li>
<li>在各种任务中，包括Masked Language Modeling、GLUE、SQuAD、Neural Machine Translation、WikiHop、HotpotQA、Natural Questions和OpenKP等，RealFormer都显著优于标准的Transformer和其变体（如BERT、ETC等）。</li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型 Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>Synthesizer Rethinking Self-Attention for Transformer Models (Google Research)</title>
    <url>/2023/08/08/Synthesizer:%20Rethinking%20Self-Attention%20for%20Transformer%20Models%20(Google%20Research)/</url>
    <content><![CDATA[<h1 id="Synthesizer-Rethinking-Self-Attention-for-Transformer-Models-Google-Research"><a href="#Synthesizer-Rethinking-Self-Attention-for-Transformer-Models-Google-Research" class="headerlink" title="Synthesizer: Rethinking Self-Attention for Transformer Models (Google Research)"></a>Synthesizer: Rethinking Self-Attention for Transformer Models (Google Research)</h1><p>论文标题: Synthesizer: Rethinking Self-Attention for Transformer Models, 作者: Yi Tay, Dara Bahri, Donald Metzler, Da-Cheng Juan, Zhe Zhao, Che Zheng, 时间: 2020, 核心算法名: Synthesizer, 论文链接: <a href="https://arxiv.org/pdf/2005.00743.pdf">https://arxiv.org/pdf/2005.00743.pdf</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Transformer模型（Vaswani等人，2017）在各种任务中都表现出了成功，这使得Transformer在近年来大大取代了一度流行的自回归和循环模型。Transformer模型的核心是查询-键-值点积注意力。Transformer模型的成功广泛地归因于这种自注意力机制，因为全连接的token图能够模型长距离依赖性，提供了强大的归纳偏见。但是，这篇论文质疑点积自注意力的真正重要性，并通过大量实验发现，随机对齐矩阵的表现出奇地好，而从token-token（查询-键）交互中学习注意力权重虽然有用，但并不那么重要。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>为了解决这个问题，作者提出了Synthesizer，一种无需token-token交互就能学习合成注意力权重的模型。实验结果显示，简单的Synthesizer在与vanilla Transformer模型的比较中，在一系列任务上都取得了高度竞争性的性能，包括机器翻译、语言建模、文本生成和GLUE&#x2F;SuperGLUE基准测试。当与点积注意力组合时，作者发现Synthesizer始终优于Transformers。此外，作者还对Synthesizer与Dynamic Convolutions进行了额外的比较，结果显示，简单的Random Synthesizer不仅比Dynamic Convolutions快60%，而且还将困惑度提高了相对3.5%。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>注意力模型被广泛应用于各种问题领域，尤其是在语言和视觉领域，这些模型因其有效性而受到欢迎。注意力模型可以追溯到机器翻译模型（Bahdanau等人，2014年；Luong等人，2015年），在这些模型中，注意力被用来学习语言对之间的软对齐。自注意力的基本角色是学习自对齐，即确定单个token相对于序列中所有其他token的相对重要性。然而，这篇论文提出，我们不仅可以不使用点积自注意力，而且也可以完全不使用基于内容的记忆式自注意力。</p>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><p><img src="/media/16900508332754/16900517291887.jpg"></p>
<ol>
<li><p><strong>Dense Synthesizer</strong>: 这是最简单的SYNTHESIZER模型变体，它依赖于每个输入token。该方法接受一个输入Xh,<code> ∈ RN×d，并产生一个输出Yh,</code> ∈ RN×d。这里，<code>表示序列长度，d表示模型的维度。首先，我们采用Fh,</code> (.)，一个参数化的函数，用于将输入Xi从d维度投影到N维度。然后，给定Bi,h,<code> ∈ RN×N，我们现在计算Yh,</code> &#x3D; softmax(Bh,<code> )Gh,</code> (Xh,<code> )，其中Gh,</code> (.)是另一个参数化函数，类似于标准Transformer模型中的Vh,<code> (值)。这种方法通过将标准Transformers中的Qh,</code> Kh,<code> &gt;替换为合成函数Fh,</code> (.)，消除了点积注意力Y &#x3D; softmax(Qh,<code> Kh,</code> &gt;)Vh,&#96;。</p>
</li>
<li><p><strong>Random Synthesizer</strong>: 这是另一个SYNTHESIZER的变体，其中注意力权重不依赖于任何输入token。相反，注意力权重被初始化为随机值。这些值可以是可训练的，也可以保持固定。给定一个随机初始化的矩阵Rh,<code>，Random Synthesizer定义为Yh,</code> &#x3D; softmax(Rh,<code> )Gh,</code> (Xh,<code> )。这里，Rh,</code> ∈ RN×N。每个头部都向网络添加了N 2个参数。Random Synthesizer的基本思想是不依赖于token-token交互或任何来自单个token的信息，而是学习一个在许多样本中全局工作良好的任务特定对齐。</p>
</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li>和其他工作一个典型工作的方法区别是什么：Synthesizer的主要区别在于它不依赖于token-token交互来学</li>
</ul>
<p>习注意力权重，而是直接合成对齐矩阵。这种方法提供了一种新的学习注意力的方式，不需要显式地进行注意力（即，没有点积注意力或基于内容的注意力）。相反，我们生成对齐矩阵，而不依赖于token-token依赖性，并探索了一系列参数化函数来合成注意力矩阵。</p>
<ul>
<li>实验效果对比：在大规模的C4数据集（Raffel等人，2019）上进行的遮罩语言建模和在SuperGLUE和GLUE基准测试上的微调中，我们显示出简单的随机Synthesizers可以胜过&#x2F;匹配Lightweight Dynamic convolutions（Wu等人，2019）以及胜过Transformers和Universal Transformers（Dehghani等人，2018）。在两个编码任务中，分解的随机Synthesizers胜过低秩的Linformers（Wang等人，2020）。</li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型 Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>T-TA (Transformer-based Text Autoencoder)</title>
    <url>/2023/08/08/T-TA%20(Transformer-based%20Text%20Autoencoder)/</url>
    <content><![CDATA[<h1 id="T-TA-Transformer-based-Text-Autoencoder"><a href="#T-TA-Transformer-based-Text-Autoencoder" class="headerlink" title="T-TA (Transformer-based Text Autoencoder)"></a>T-TA (Transformer-based Text Autoencoder)</h1><p>论文标题: Fast and Accurate Deep Bidirectional Language Representations for Unsupervised Learning, 作者: Joongbo Shin, Yoonhyung Lee, Seunghyun Yoon, Kyomin Jung, 时间: 2020年4月, 核心算法名: Transformer-based Text Autoencoder (T-TA), 论文链接: <a href="https://arxiv.org/abs/2004.08097">https://arxiv.org/abs/2004.08097</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>尽管BERT在各种监督学习任务中取得了成功的性能提升，但将BERT应用于无监督任务仍然存在一个限制，即它需要重复推理以计算上下文语言表示。为了解决这个限制，我们提出了一种名为Transformer-based Text Autoencoder (T-TA)的新型深度双向语言模型。T-TA可以无重复地计算上下文语言表示，并具有像BERT一样的深度双向架构的优点。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>在CPU环境的运行时实验中，我们提出的T-TA在重排任务中的性能比基于BERT的模型快6倍多，在语义相似性任务中快12倍。此外，T-TA在上述任务中显示出与BERT相比的竞争甚至更好的准确性。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ul>
<li>BERT和其变体在学习自然语言表示方面取得了显著的改进，并在各种下游任务如GLUE基准测试和问题回答等方面取得了最先进的性能。</li>
<li>对于无监督任务，研究人员采用了最近的语言表示模型，并研究了它们的有效性。token一个典型的例子是ASR和NMT任务的N-best列表重排。</li>
<li>另一方面的研究包括减少BERT的计算时间和内存消耗。Lan等人提出了参数减少技术，实现了18倍的参数减少和1.7倍的训练时间加速。</li>
</ul>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><p><img src="/media/16900514233052/16900516847446.jpg"></p>
<ol>
<li><p><strong>语言自编码(LAE)</strong>: 我们提出了一种新的学习目标，称为语言自编码(LAE)，用于无重复地获取完全上下文化的语言表示。LAE使输出变得与输入相同，目标是一次预测文本序列中的每个token，而不仅仅是将输入复制到输出。为了完成这个任务，语言模型应该在避免过拟合的同时复制整个输入。否则，模型只会输出从输入表示复制的表示，而不学习语言的任何统计信息。为此，从i-th输入到i-th输出的信息流应该在模型内部被阻止。</p>
</li>
<li><p><strong>基于Transformer的文本自编码器(T-TA)</strong>: 我们介绍了一种新的深度双向语言模型的架构，称为T-TA，即基于Transformer的文本自编码器。为了学习提出的LAE，我们在T-TA内部开发了一个对角线遮蔽操作和一个输入隔离机制。这两个组件使得提出的T-TA能够一次计算上下文化的语言表示，同时保持BERT的深度双向属性。</p>
</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li>和其他工作一个典型工作的方法区别是什么: 与BERT相比，T-TA在无监督任务中的运行时间更短，性能更好。在CPU环境的运行时实验中，我们提出的T-TA在重排任务中的性能比基于BERT的模型快6倍多，在语义相似性任务中快12倍。此外，T-TA在上述任务中显示出与BERT相比的竞争甚至更好的准确性。</li>
<li>实验效果对比: 在重排任务中，即使在更快的推理中，T-TA也能达到与BERT竞争的性能。此外，T-TA在无监督的语义文本相似性任务中的表现优于BERT，Pearson’s r得分高达8点。</li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>TooEasy Or TooDifficult</title>
    <url>/2016/05/11/TooEasyOrTooDifficult/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>给你定义两类值，P[i]表示以第i个字符为中心的最长回文串长度，MZ和max{P[i]}有关，FJD为连续若干个P[i]异或和的最大值。问你MZ和FJD谁大<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
</ul>
<ol>
<li><p>解决MZ就是最裸的manacher算法，FJD则利用到一个性质sum[j]^sum[i] &#x3D; p[i]^…P[j];这样转换之后就是求最大的sum[j]^sum[i],这个问题在问题A中谈论过了，就是建立01二叉树，然后把sum[i]全部插入，再全部走一遍</p>
</li>
<li><p>当时生成插入01树的时候写挫了，一直死循环，debug半天</p>
</li>
</ol>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>没啥坑点</p>
</li>
<li><p>常规题</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: j.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月07日 星期六 20时19分58秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> p[maxn];</span><br><span class="line"><span class="type">char</span> s[maxn],  ss[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">2</span>*n+<span class="number">2</span>;</span><br><span class="line">    ss[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    ss[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ss[i*<span class="number">2</span>+<span class="number">2</span>] = s[i];</span><br><span class="line">        ss[i*<span class="number">2</span>+<span class="number">3</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ss[n*<span class="number">2</span>+<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> id, ma = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; ma) &#123;</span><br><span class="line">            p[i] = <span class="built_in">min</span>(p[id*<span class="number">2</span>-i], ma-i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;ss[i+p[i]] == ss[i-p[i]]; p[i]++);</span><br><span class="line">        <span class="keyword">if</span>(i+ p[i] &gt; ma) &#123;</span><br><span class="line">            id = i;</span><br><span class="line">            ma = i+p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    sum[<span class="number">0</span>] = p[<span class="number">2</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>]^(p[i*<span class="number">2</span>+<span class="number">2</span>]<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//    pr(i);pr(sum[i-1]);pr(p[i*2+2]-1);prln(sum[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ch[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> sz;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> rt, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> son = (x&gt;&gt;(rt<span class="number">-1</span>))&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch[pos][son] == <span class="number">-1</span>) ch[pos][son] = ++sz;</span><br><span class="line"><span class="comment">//    pr(rt);pr(ch[pos][son]);pr(pos);prln(son);</span></span><br><span class="line">    <span class="built_in">add</span>(x,rt<span class="number">-1</span>,ch[pos][son]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rt, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt == <span class="number">0</span>) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="comment">//pr(y);pr(pos);prln(rt);</span></span><br><span class="line">    <span class="type">int</span> son = (x&gt;&gt;(rt<span class="number">-1</span>))&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//pr(son);</span></span><br><span class="line">    <span class="keyword">if</span>(ch[pos][!son] != <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">query</span>(x,y&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, rt<span class="number">-1</span>, ch[pos][!son]);</span><br><span class="line">    <span class="comment">//prln(ch[pos][son]);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(x, y &lt;&lt; <span class="number">1</span>, rt<span class="number">-1</span>, ch[pos][son]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getfjd</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">getsum</span>(n);</span><br><span class="line">    sz = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//memset(ch,-1,sizeof ch);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(sum[i], <span class="number">31</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(sum[i], <span class="number">0</span>, <span class="number">31</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//pr(sum[i]);</span></span><br><span class="line">        <span class="comment">//pr(i);prln(ans);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sz; ++i) ch[i][<span class="number">0</span>] = ch[i][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mod;</span><br><span class="line"><span class="function">ll <span class="title">ret</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        y = y/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ch,<span class="number">-1</span>,<span class="keyword">sizeof</span> ch);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        ll len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="built_in">manacher</span>(len);</span><br><span class="line">        ll ans = <span class="built_in">getfjd</span>(len);</span><br><span class="line">        <span class="type">int</span> ma = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span>(p[i*<span class="number">2</span>+<span class="number">2</span>]<span class="number">-1</span>&gt;ma) ma=p[i*<span class="number">2</span>+<span class="number">2</span>]<span class="number">-1</span>;</span><br><span class="line">        mod = ma/<span class="number">3</span>*<span class="number">5</span>+<span class="number">1</span>;</span><br><span class="line">        ll mz = <span class="built_in">ret</span>(ma,len*len*len) + ma*<span class="number">4</span>/<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(mz &gt; ans) <span class="built_in">printf</span>(<span class="string">&quot;liujc\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;luoxinchen\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>manacher</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title>T5-谷歌</title>
    <url>/2023/08/08/T5-%E8%B0%B7%E6%AD%8C/</url>
    <content><![CDATA[<h1 id="T5-谷歌"><a href="#T5-谷歌" class="headerlink" title="T5-谷歌"></a>T5-谷歌</h1><p>论文标题: “Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer”, 作者: Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, Peter J. Liu, 时间: 2019年10月, 核心算法名: T5 (Text-to-Text Transfer Transformer), 论文链接: <a href="https://arxiv.org/abs/1910.10683">https://arxiv.org/abs/1910.10683</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>该论文的目标不是提出新的方法，而是提供一个全面的视角来理解当前领域的状况。因此，这项工作主要包括对现有技术的调查、探索和实证比较。作者还通过扩大系统研究的洞察力（训练多达110亿参数的模型）来探索当前方法的极限，从而在许多任务中获得了最先进的结果。为了进行这种规模的实验，作者引入了“巨大的清洁爬行语料库”（C4），这是一个由网络上抓取的数百GB的清洁英文文本组成的数据集。认识到转移学习的主要用途是在数据稀缺的环境中利用预训练模型，作者发布了他们的代码、数据集和预训练模型（Page 3）。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>该论文通过采用合理的基线（在第3.1节中描述），并一次改变设置的一个方面，系统地研究了这些贡献。例如，在第3.3节中，作者在保持实验流程不变的情况下，测量了不同无监督目标的性能。这种“坐标上升”方法可能会错过二阶效应（例如，某个特定的无监督目标可能在比基线设置更大的模型上效果最好），但进行所有可能组合的探索将是不切实际的（Page 10）。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>该论文的研究是在许多相关工作的基础上进行的，包括BERT、GPT-2、RoBERTa、XLNet等。这些工作都在一定程度上影响了T5的设计和实现。然而，T5的目标是通过统一的文本到文本框架，对这些方法进行全面的比较和分析，以理解各种技术的贡献和重要性（Page 10）。</p>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><ol>
<li>T5采用了文本到文本的框架，这提供了一种简单的方法来训练单一模型以处理各种文本任务，使用相同的损失函数和解码过程。这种方法可以成功应用于生成任务（如抽象摘要）、分类任务（如自然语言推理）甚至回归任务（如STS-B）。尽管简单，但文本到文本框架的性能与任务特定的架构相当，并最终在与规模结合时产生了最先进的结果（Page 41）。</li>
<li>在无监督目标的探索中，作者发现去噪目标在预训练中优于语言建模和解混乱。他们没有观察到去噪目标的许多变体之间的显著差异。然而，不同的目标（或目标的参数化）可以导致不同的序列长度，从而导致不同的训练速度（Page 24-25）。</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li><p>与其他工作的方法区别是什么<br>T5的主要区别在于它采用了统一的文本到文本框架，这使得它能够在各种任务上使用相同的模型和损失函数。此外，T5还进行了大规模的实验，以探索转移学习的极限，并在许多任务中达到了最先进的结果（Page 41）。</p>
</li>
<li><p>实验效果对比<br>在最后的一组实验中，T5在24个任务中的18个任务上实现了最先进的性能。预期地，他们最大的（110亿参数）模型在所有任务中的性能最好。他们的T5-3B模型变体在几个任务中超越了之前的最先进的技术，但将模型规模扩大到110亿参数是实现最佳性能的最重要因素（Page 38）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>c++书籍单</title>
    <url>/2016/11/09/booklist/</url>
    <content><![CDATA[<h3 id="想看书籍c-系列"><a href="#想看书籍c-系列" class="headerlink" title="想看书籍c++系列"></a>想看书籍c++系列</h3><p>转自<a href="https://www.zhihu.com/question/20410487">知乎</a></p>
<h5 id="阶段-1"><a href="#阶段-1" class="headerlink" title="阶段 1"></a>阶段 1</h5><p>《Essential C++》</p>
<blockquote>
<p>这是一本内容不多但很实用的C++入门书籍，强调快速上手与理解C++编程。本书主要围绕一系列逐渐复杂的程序问题，以及用以解决这些问题的语言特性展开讲解。你不只学到C++的函数和结构，也会学习到它们的设计目的和基本原理。</p>
</blockquote>
<span id="more"></span>
<p>《C++ Primer》<br>本书对C++基本概念、技术、以及现代C++编程风格进行了全面而且权威的阐述，是C++初学者的最佳指南；本书可以帮助你编写实用的程序，而无需首先精通每个语言细节。对于中高级程序员，本书也是不可或缺的参考书。</p>
<h5 id="阶段-2"><a href="#阶段-2" class="headerlink" title="阶段 2"></a>阶段 2</h5><p>《Effective C++》和《More effective C++》</p>
<blockquote>
<p>作者是Scott Meyers。你应该熟读它们，并清楚地理解每个项目。该书围绕55条准则，每一条都介绍了一个可让你写出更好的C++程序代码的方法，并以特别设计过的例子详加讨论。</p>
</blockquote>
<p>《Exceptional C++（C++编程剖析）》和《More exceptional C++》</p>
<blockquote>
<p>这两本书中都包含了40个C++编程问题，这些问题会让你磨练自己的技能，最终成为优秀的C++程序员。这些问题是Herb Sutter精心挑选，与ISO&#x2F;ANSI C++官方标准相一致，帮助程序员在设计、架构和编码过程中保持良好的风格，从而使编写的C++软件更健壮、更高效。</p>
</blockquote>
<h5 id="阶段-3"><a href="#阶段-3" class="headerlink" title="阶段 3"></a>阶段 3</h5><p>《Inside the C++ object model（深度探索C++对象模型）》</p>
<blockquote>
<p>本书专注于C++面向对象程序设计的底层机制，包括结构式语意、临时性对象的生成、封装、继承，以及虚拟——虚拟函数和虚拟继承，帮助你理解程序的底层实现，以便写出更高效的代码。</p>
</blockquote>
<p>《The design and evolution of C++（C++语言的设计与演化）》</p>
<blockquote>
<p>本书作者也是C++语言的设计者Bjarne Stroustrup，作者在书中综合性地介绍了C++的发展历史，C++中各种重要机制的本质意义和设计背景，这些机制的基本用途和使用方法，讨论了C++所适合的应用领域及其未来的发展前景，既没有忽略关键性的详情，又没有过多地陷入技术细节。</p>
</blockquote>
<h5 id="阶段-4"><a href="#阶段-4" class="headerlink" title="阶段 4"></a>阶段 4</h5><p>《The C++ standard library（C++标准程序库）》</p>
<blockquote>
<p>这是标准模板库字典，你可以在本书中找到STL相关的一切知识。本书焦点放在标准模板库、检查容器、迭代器、函数对象和STL算法上。每一个元素都有深刻的呈现，包括其介绍、设计、运用实例、细节解说、陷阱、意想不到的危险，以及相关类别和函数等。</p>
</blockquote>
<p>《Effective STL》</p>
<blockquote>
<p>这是Scott Meyers的第三本C++专著，也是学习STL最权威的书籍。作者对书中的50个指导方针都作了详尽的分析，并配以示例。通过这些规则，C++开发者可以最大限度地使用STL。</p>
</blockquote>
<p>《Generic programming and the STL（泛型编程与STL）》</p>
<blockquote>
<p>本书阐述了泛型程序设计的核心理念：concepts（概念）、modeling（模型）和refinement（改善），并为你展示这些观念如何导出STL的基础概念：iterators（迭代器）、containers（容器）和function objects（函数对象）。按照本书所述，你可以把STL想象成一个由concepts组成的library，你将学习到STL正式结构并理解其强大的优势。</p>
</blockquote>
<h5 id="阶段-5"><a href="#阶段-5" class="headerlink" title="阶段 5"></a>阶段 5</h5><p>《Exceptional C++ style》</p>
<blockquote>
<p>作者为Herb Sutter。本书同样提出了40个C++风格相关的问题，对一些至关重要的C++细节和相互关系提出了新的见解，为当今的关键C++编程技术（如泛型编程、STL、异常安全等）提供了新的策略，帮助开发者在开销与功能之间、优雅与可维护性之间、灵活性与过分灵活之间寻找完美的平衡点。</p>
</blockquote>
<p>《C++ template》</p>
<blockquote>
<p>这是一本关于C++模板的完整的参考手册和教程，它强调模板的使用实践，包含了现实世界中的例子。每个C++程序员都应该好好读一读这本书。</p>
</blockquote>
<p>《Modern C++ design（现代C++设计）》</p>
<blockquote>
<p>作者Andrei Alexandrescu为C++程序员打开了一个新的局面。本书提供了一些针对软件设计的前沿方法，如联合设计模式、泛型编程，使程序员可以编写有表现力的、灵活的、高度可重用的代码。</p>
</blockquote>
<p>《Thinking in C++（C++编程思想）》</p>
<blockquote>
<p>C++ 领域权威著作，介绍了C++实用的编程技术和最佳的实践方法。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Taosama和煎饼</title>
    <url>/2016/05/23/Taosama%E5%92%8C%E7%85%8E%E9%A5%BC/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li><p>韬韬想吃煎饼但是有急事,一个煎饼有n个工序,每个工序i有着A[i]美味度,韬韬有m个道具,每个道具用一次可以前进b[i]个单位,每个工序一旦被跳过得不到美味度,问你使用这些工具最多获得多少美味度*(0&lt;&#x3D;b[i]&lt;&#x3D;4,0&lt;&#x3D;a[i]&lt;&#x3D;100,0&lt;&#x3D;n&lt;&#x3D;350,0&lt;&#x3D;m&lt;&#x3D;120)*,确保b[i]的和是n-1</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
<li><p>建立状态</p>
</li>
</ul>
<pre><code>dp[i][a][b][c][d]表示处于i位置还剩abcd个四种道具(a表示前进b[1]个道具)最多能够获得多少美味度

状态转移

dp[i][a][b][c][d]可以由dp[i-1][a-1][b][c][d]等四种状态转移过来
</code></pre>
<ul>
<li>状态优化</li>
</ul>
<pre><code>上面的状态很容易想,但是350 * 40 * 40 * 40 * 40复杂度很高,我们可以发现,这五个变量只要确定四个,那么第五个变量是确定的,所以我们可以减少一维,dp[a][b][c][d]就好了,复杂度40 * 40 * 40 * 40完美过题
</code></pre>
<ul>
<li>超时原因</li>
</ul>
<pre><code>由于建立状态思维定式,所以建立的状态是dp[350][40][40][40],超时了,但仔细发现这里的350有很多状态达不到
</code></pre>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>技巧</li>
</ul>
<pre><code>-    对于这种固定形式的转移,记忆化搜索写起来最快
-    建立状态的时候如果有多种选择首先找范围小的,其次找容易实现的
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: c.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月13日 星期五 23时22分57秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, dp[<span class="number">41</span>][<span class="number">41</span>][<span class="number">41</span>][<span class="number">41</span>], cnt[<span class="number">41</span>][<span class="number">41</span>][<span class="number">41</span>][<span class="number">41</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">400</span>];</span><br><span class="line"><span class="type">int</span> kase;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;ans = dp[a][b][c][d];</span><br><span class="line">    <span class="keyword">if</span>(ans &gt;= <span class="number">0</span> &amp;&amp; cnt[a][b][c][d] == kase) <span class="keyword">return</span> ans;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a+b+c+d==<span class="number">0</span>) <span class="keyword">return</span> ans=num[n];</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        temp = <span class="built_in">dfs</span>(a<span class="number">-1</span>, b, c, d);</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; ans) ans = temp;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(b &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        temp = <span class="built_in">dfs</span>(a, b<span class="number">-1</span>, c, d);</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; ans) ans = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        temp = <span class="built_in">dfs</span>(a, b, c<span class="number">-1</span>, d);</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; ans) ans = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        temp =  <span class="built_in">dfs</span>(a, b, c, d<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; ans) ans = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += num[n-a-b*<span class="number">2</span>-c*<span class="number">3</span>-d*<span class="number">4</span>];</span><br><span class="line">    <span class="comment">//pr(a);pr(b);pr(c);prln(d);</span></span><br><span class="line">  <span class="comment">//  prln(ans);</span></span><br><span class="line">    cnt[a][b][c][d] = kase;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> e[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="comment">//	freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t, x, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        kase++;</span><br><span class="line">        <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span> e);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            e[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">dfs</span>(e[<span class="number">1</span>],e[<span class="number">2</span>],e[<span class="number">3</span>],e[<span class="number">4</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第二场联合赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>UNILM Unified Pre-training for Language Understanding and Generation</title>
    <url>/2023/08/08/UNILM%20/</url>
    <content><![CDATA[<h1 id="UNILM"><a href="#UNILM" class="headerlink" title="UNILM"></a>UNILM</h1><p>Unified Pre-training for Language Understanding and Generation<br>这篇论文的作者是Liu等人，发表于2019年。论文提出了一种新的统一预训练语言模型（UNILM），可以应用于自然语言理解和生成任务。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>预训练的语言模型已经在各种自然语言处理任务中取得了显著的进步。预训练的语言模型通过预测基于大量文本数据的上下文中的词来学习上下文化的文本表示，并可以进行微调以适应下游任务。然而，现有的预训练模型，如BERT，主要用于自然语言理解任务，而不适用于自然语言生成任务。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>本文提出了一种新的统一预训练语言模型（UNILM），可以应用于自然语言理解和生成任务。UNILM是一个多层Transformer网络，共同预训练在大量文本上，针对三种类型的无监督语言建模目标进行优化：单向LM，双向LM和序列到序列LM。为了控制预测条件的上下文，我们使用特定的自注意力掩码来控制共享的Transformer网络。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>ELMo、GPT和BERT等预训练模型在自然语言处理任务中取得了显著的进步。然而，这些模型主要用于自然语言理解任务，而不适用于自然语言生成任务。</p>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><ol>
<li>UNILM的预训练包括三种类型的语言建模任务：单向、双向和序列到序列预测。统一的建模是通过使用共享的Transformer网络和利用特定的自注意力掩码来控制预测条件的上下文来实现的。这种方法的好处是可以通过使用不同的自注意力掩码来配置，以聚合不同类型的语言模型的上下文，因此可以用于自然语言理解和生成任务。</li>
<li>UNILM的输入表示遵循BERT的方式。文本被分词为WordPiece单元。对于每个输入token，其向量表示是通过将相应的token嵌入、位置嵌入和段落嵌入相加来计算的。因为UNILM是使用多种LM任务进行训练的，所以段落嵌入也起到了LM标识符的作用，我们为不同的LM目标使用不同的段落嵌入。</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li>与BERT等模型不同，UNILM可以通过使用不同的自注意力掩码来配置，以聚合不同类型的语言模型的上下文，因此可以用于自然语言理解和生成任务。</li>
<li>实验结果表明，我们的模型作为双向编码器，与BERT在GLUE基准测试和两个抽取式问题回答任务（即SQuAD 2.0和CoQA）上的比较有利。此外，我们在五个自然语言生成数据集上展示了UNILM的有效性，其中它被用作序列到序列模型，在CNN&#x2F;DailyMail和Gigaword抽象摘要，SQuAD问题生成，CoQA生成问题回答，和DSTC7对话响应生成上创造了新的最先进的结果。</li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>第二场联合总结</title>
    <url>/2016/05/11/dp%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p><a href="http://acm.scu.edu.cn/soj/contest/contest.action?cid=367">传送门</a></p>
<h3 id="A-雷神之路"><a href="#A-雷神之路" class="headerlink" title="A 雷神之路"></a>A 雷神之路</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>在一个坐标轴上面起始位置是0，你可以往右走一步，两步，三步。其中某些位置不能走，问你走到位置n有多少种方法（1&lt;&#x3D; n &lt;&#x3D; 1e18）</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>这题是走楼梯的进阶版，状态很好想dp[n]，转移有三种：走一步两步三步转移过来。不过由于n太大，很容易想到矩阵加速。</li>
<li>用矩阵A表示第i个可走，矩阵B表示第i个不可走。有些地方x不能走，那么我只要用矩阵加速求出第x-1个矩阵C，那么第x个矩阵就是C*B，最后得出第n个矩阵</li>
</ul>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>dp[n] &#x3D; dp[n-1] + dp[n-2] + dp[n-3] (n&gt;&#x3D;3)所以我们第一个矩阵是从2开始的，小于2的方案要手动打出来</li>
</ul>
<h3 id="B-Snowd-修长廊"><a href="#B-Snowd-修长廊" class="headerlink" title="B Snowd 修长廊"></a>B Snowd 修长廊</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><ul>
<li>现在要修长廊覆盖n个点，第i个点可以单独修一个长廊，也可以修到前面第j个点（覆盖j到i之间的点），现在修i和j之间的长廊花费cost(i,j) &#x3D; W + (x $<em>{i}$ － x$</em>{j}$ ) $^_{2}$,其中W是固有花费,现在求最小花费是多少</li>
</ul>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul>
<li><p>我们状态很好建立,dp[i]表示覆盖到第i个点为止至少需要花费多少,但是他可以有很多状态转移过来.</p>
</li>
<li><pre><code>  dp[i] = min(dp[j-1]+cost(j,i));
</code></pre>
</li>
<li><p>如果现在有两个状态j和k(其中j&gt;k)可以转移过来.那么用单调队列dp思想把这两个相减</p>
<pre><code>  dp[j] + cost(j,i) - dp[k] - cost(k,i)
      
   =(dp[j] +x[j]*x[j])-(dp[k]+ x[k]*x[k]) -　2*x[i]*(x[j]-x[k])
  
</code></pre>
<p>  那么也就是说如果dp[j]转移过来比dp[k]更优的话,就有上式小于 0,那么我们在更新最优的dp[y]的时候,如果前面存在一个状态x比状态i差,那么便有上式成立</p>
<p>  同时可以发现如果现在就已经成立,那么这个式子对y以后的状态都会成立,因为对y以后的x<a href="i%3E=y">i</a>上式也成立(这个就是斜率dp的特点,总会有一个自变量一直递增或递减),那么状态x就属于无用状态应该从队列中剔除</p>
<p>  <strong>判定条件一:如果i点没有j点优(也就是说j点比i点更优)的条件是i和j(i&lt;j)斜率小于2x[i]</strong></p>
</li>
<li><p>那么如何保证队列起第一个就是最优的呢?</p>
<ul>
<li><p><strong>感性的认识:</strong></p>
<p>  根据上面的式子我们可以一直判断第一个和第二个元素然后剔除,从而使得保证队队列第一个一定比第二个更优,那么剩下的就需要保证第一个比第三个,第一个比第四个更优…这个性质一直成立就好了</p>
<p>  假设上面这个性质成立则有:23点的斜率大于12点,34点斜率大于12点…</p>
</li>
</ul>
<p>  但是确保每相邻两个点斜率大于12点不具有<strong>传递性</strong>,所以我们可以缩小简化:23点的斜率大于12点,34点斜率大于23点…从而形成了<strong>下凸包</strong></p>
<pre><code>  从结果看:斜率递增保证了下凸包,而下凸包其实是保证了**:第三个点没有第二个点优,第四个点没有三个点优..**,因为第一个破坏下凸包性质的点一定不是最优,可参考理性认识的证明
  
  
  所以我们要维护上面两个性质:1:第一个点比第二个点优,2:第三个点没有第二个点优,第四个点没有三个点优...(用维护斜率递增实现)**
</code></pre>
</li>
</ul>
<h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h4><ul>
<li><p>如何证明维护的队列的第一个就是最优的呢?<br>-    <strong>理性认识:</strong><br>   dp[i] &#x3D; dp[j] + x[j] $^_{2}$ + x[i]$^_{2}$ +　2x[i]*x[j] + W</p>
<p>   dp[i] - W - x[i]$^_{2}$  &#x3D; dp[j] + x[j] $^_{2}$ +　2x[i]*x[j] </p>
<p>   从上面这个式子看出dp[i] , x[i]$^_{2}$ ,Ｗ这三个相对于i是定值</p>
<p>   **问题转换:**我们要找到这样一个 x[j] 和 dp[j] + x[j] $^_{2}$ 使得 dp[i] 最小,看成b &#x3D; y - kx,也就是b最小.从而我们可以画出一些点(2x[j],dp[j] + x[j] $^_{2}$),用斜率固定k的直线从下面往上面开始扫描,第一个接触到的点就是我们要找的最优点.这样找的话就会发现一个特点,上凸包的转折点永远不会被扫到,所以也应该剔除.</p>
<p>   如果我们在每一次插入的时候一直这样判断,那么就能够保证最后两个斜率一定大于前两个点的斜率,由于插入斜率大小具有<strong>传递性</strong>,所以能够保证<strong>斜率递增</strong></p>
<p>   <strong>但是光斜率递增就一定能够使得第一个最优吗?</strong></p>
<p>   确保第一个最优的充分必要条件是每个点和第一个点的斜率大于等于2x[i],这样看来显然不能够确保第一个最优.(<strong>举一个极限的例子,所有点和第一个点的斜率都小于2x[i]但是却递增</strong>)</p>
<p>   为了弥补上面的不足,可以让第一个优于第二个,也就是12斜率大于2x[i],由于上面凸包的性质使得第一个点和所有点斜率都大于2x[i]也就是说,以后的点不能够比第一个点更优.所以:<strong>第一个是最优的</strong></p>
</li>
</ul>
<h3 id="C-Taosama和煎饼"><a href="#C-Taosama和煎饼" class="headerlink" title="C  Taosama和煎饼"></a>C  Taosama和煎饼</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><ul>
<li>韬韬想吃煎饼但是有急事,一个煎饼有n个工序,每个工序i有着A[i]美味度,韬韬有m个道具,每个道具用一次可以前进b[i]个单位,每个工序一旦被跳过得不到美味度,问你使用这些工具最多获得多少美味度*(0&lt;&#x3D;b[i]&lt;&#x3D;4,0&lt;&#x3D;a[i]&lt;&#x3D;100,0&lt;&#x3D;n&lt;&#x3D;350,0&lt;&#x3D;m&lt;&#x3D;120)*,确保b[i]的和是n-1</li>
</ul>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><ul>
<li>建立状态</li>
</ul>
<pre><code>dp[i][a][b][c][d]表示处于i位置还剩abcd个四种道具(a表示前进b[1]个道具)最多能够获得多少美味度

状态转移

dp[i][a][b][c][d]可以由dp[i-1][a-1][b][c][d]等四种状态转移过来
</code></pre>
<ul>
<li>状态优化</li>
</ul>
<pre><code>上面的状态很容易想,但是350 * 40 * 40 * 40 * 40复杂度很高,我们可以发现,这五个变量只要确定四个,那么第五个变量是确定的,所以我们可以减少一维,dp[a][b][c][d]就好了,复杂度40 * 40 * 40 * 40完美过题
</code></pre>
<ul>
<li>超时原因</li>
</ul>
<pre><code>由于建立状态思维定式,所以建立的状态是dp[350][40][40][40],超时了,但仔细发现这里的350有很多状态达不到
</code></pre>
<h4 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h4><ul>
<li>技巧</li>
</ul>
<pre><code>-    对于这种固定形式的转移,记忆化搜索写起来最快
-    建立状态的时候如果有多种选择首先找范围小的,其次找容易实现的
</code></pre>
<h3 id="D-任务"><a href="#D-任务" class="headerlink" title="D 任务"></a>D 任务</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><ul>
<li>有两台机器n个任务,每个任务i在机器A完成时间是a[i],B上面完成时间是b[i],任务i可以被处理当前仅当每个任务j(i&gt;j)已经被完成或者正在进行.求最少完成任务的时间(n&lt;2000,a[i],b[i]&lt;&#x3D;3000)</li>
</ul>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><ul>
<li>首先读清楚题目意思</li>
</ul>
<pre><code>**任务i可以被处理当前仅当每个任务j(i&gt;j)已经被完成或者正在进行**

上面这句话有什么用?

仔细分析后可以发现上面这个性质确保了执行任意任务的时候机器AB时间差不会超过3000

假如A比B将少运行时间超过3000,那么现在放置任务i+1
-    那么任务i+1不能放置机器A最开始空闲的时候,因为这样B机器必然(B多A3000时间)有任务j(j&lt;i)还没有没执行;那么任务i+1只能当道B机器运行最后一个任务j的起始时间上去,这样的方案必然没有比任务j放置到A机器方案优(可以画图模拟一下)
-    把任务i+1放置到机器B,那么这种方案将继续造成恶性循环又进入此状态,显然最终这种方案不优

所以任一个任务选择的时候AB机器运行结束时间差不能够3000

**建立状态**

dp[i][j]表示完成任务i并且机器AB运行结束时间差为j的最少时间,(j&gt;0表示A比B多j,否则B比A多-j,后面右移3000,保证都是正数)

**状态转移**

dp[i][j]由dp[i-1][j+a[i]和dp[i-1][j-b[i]]转移过来,其中要注意任务i放到机器A或B中可能对时间没有影响
</code></pre>
<h4 id="思考-3"><a href="#思考-3" class="headerlink" title="思考"></a>思考</h4><ul>
<li><strong>错误分析</strong></li>
</ul>
<pre><code>-    没有对非法状态进行限制,比如状态转移的时候,放置任务i到机器A,必须设定任务i时间当值 &gt;= B机器最后一个任务j放置时间!!!确保i之前的任务被处理完或正被处理
-    没有考虑任务i放置到机器A后对时间无影响的情况
</code></pre>
<h3 id="E-goozy搭积木"><a href="#E-goozy搭积木" class="headerlink" title="E goozy搭积木"></a>E goozy搭积木</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><ul>
<li>goozy对积木十分的狂热，今天他想搭一个双子塔（就是两个高度一样的塔）！他想知道，用现有的积木，能不能实现这个想法.积木个数n(1 &lt;&#x3D; n &lt;&#x3D; 50)，每个积木的高度hi(1 &lt;&#x3D; hi &lt;&#x3D; 500000),题目保证所有积木高度总和不超过500000。</li>
</ul>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><ul>
<li>建立状态</li>
</ul>
<pre><code>这题和能不能把所有的平分是不一样的,因而我只要保证有一种方案把积木部分平分就好了

所以建立状态不能用dp[i][j]表示i木块j高度是否可达

状态是dp[i][j]表示前i个木块使得两份木块高度差为j的最大可达高度是多少.
</code></pre>
<ul>
<li>状态转移</li>
</ul>
<pre><code>状态转移就很简单了,积木i放到比较高的那一方或者比较低的那一方
    
    放到比较高的一方
    
    dp[now][j+h] = max(dp[now][j+h],dp[1-now][j]+h);
    
    放到比较低的一方
    
    newh = max(dp[1-now][j]-j+h, dp[1-now][j]);
    
    dp[now][abs(h-j)] = max(dp[now][abs(h-j)], newh);
    
</code></pre>
<h4 id="思考-4"><a href="#思考-4" class="headerlink" title="思考"></a>思考</h4><ul>
<li>有时候dp建立状态后发现某一位范围过大,不能直接dp[i][j]的时候可以考虑特殊性质,然后对他们的差进行状态转移,正如D题一样</li>
</ul>
<h3 id="F-先锋看烟花"><a href="#F-先锋看烟花" class="headerlink" title="F 先锋看烟花"></a>F 先锋看烟花</h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><ul>
<li>一共有n个地点（1到n排列），一共有m个烟花，每个烟花放出的地点ai和时间ti，每个烟花有观赏值bi，对于每个烟花，对先锋的幸福度贡献bi-|ai-cur|，其中cur表示放第i个烟花时先锋所处的位置，因此，当先锋离烟花太远时，幸福度甚至会下降！已知先锋每秒最多运动d距离，问这个晚上先锋看烟花能获得的最大幸福度。</li>
</ul>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><ul>
<li><p>这相当于是一道移动接苹果的题目,只不过每秒移动范围为d并且烟花放的每一个点都有一个贡献值可为负数</p>
</li>
<li><p><strong>状态建立</strong></p>
</li>
</ul>
<pre><code>dp[i][j]表示第i个烟花位于j位置最多能够获得多少幸福感

**状态转移**

    dp[i][j]=min(dp[i-1][k]+bi-|ai-j|);
    
    k和j差值不超过(t[i] - t[i-1]) * d
    
**转移优化**

直接转移显然不行,那么就可以分成两种情况并进行单调队列优化了
若ai&gt;cur
    
    dp[i][j]=min(dp[i-1][k]+bi-ai+j);
那么维护一个和j差范围处于(t[i]-t[i-1])*d的队列

如果 dp[i-1][k] 和 dp[i-1][kk] 都在队列中并且 k &lt; k &amp;&amp;  dp[i-1][k] &lt; dp[i-1][kk] 那么在对i时刻烟花j以后的位置,都不会选择dp[i-1][k]了,因为dp[i-1][kk] 一定比他优,所以dp[i-1][k]这个状态就要从队列中间pop出来

所以队首的只要处于范围之内一定最优

这个队列最多插入n次pop n次,因而复杂度是O(n)
</code></pre>
<h4 id="思考-5"><a href="#思考-5" class="headerlink" title="思考"></a>思考</h4><ul>
<li>当遇到一种可以由很多种状态转移过来的时候,考虑一下nlogn线段树或树状数组查询或单调队列或斜率优化</li>
</ul>
<h3 id="H-又见背包"><a href="#H-又见背包" class="headerlink" title="H 又见背包"></a>H 又见背包</h3><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><ul>
<li>有n种大小不同的数字a_i,每种m_i个，判断是否可以从这些数字中选出若干使它们的和恰好为k。(0&lt;n&lt;&#x3D;100,0&lt;k&lt;&#x3D;1e5)</li>
</ul>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><ul>
<li><strong>建立状态</strong></li>
</ul>
<pre><code>dp[i][j]表示前i个物品能不能组成和是j
</code></pre>
<ul>
<li><strong>状态转移</strong></li>
</ul>
<pre><code>dp[i][j] |= dp[i-1][j-a[i]];
</code></pre>
<ul>
<li><strong>状态优化</strong></li>
</ul>
<pre><code>上面的状态首先可以二进制对个数进行优化,然后可以发现单独的一次转移居然只是转移一个bool,太浪费时间了,所以充分使用int或ll的位数,我们可以把j分成64位一组,一次性转移一组这样转移负责度就除以64了相当于降了两个数量级了

现在复杂度是n*k*logm/64,这样相当于消去logm而且转移过程还是位运算很快,所以就过了
</code></pre>
<h4 id="思考-6"><a href="#思考-6" class="headerlink" title="思考"></a>思考</h4><ul>
<li>如果以后遇到bool为dp存的状态的时候,那么这个状态肯定是不好的,这时候要么像这题一样压缩一下转移,要么重新建一个状态</li>
</ul>
<h3 id="I-Mingo的游戏"><a href="#I-Mingo的游戏" class="headerlink" title="I Mingo的游戏"></a>I Mingo的游戏</h3><h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><ul>
<li>Mingo 最近迷上了一款电子游戏。这款游戏有N个关卡，编号为1到n。这些关卡可以被玩家分为K(1&lt;&#x3D;K&lt;&#x3D;N)组，每组包含至少一个并且编号连续的关卡。<br>这款游戏有些很奇怪的规则：</li>
</ul>
<pre><code>1.如果所有的关卡都被通关，那么这个游戏立即结束，否则系统会找到第一个包含还没有通过的关卡的那组，设X是这组的编号。 

2.设在X组里，已经通关的关卡编号为i,i+1，i+2,...,j。那么j+1为最早的一个没有通关的关卡。每一个关卡都有一个权重ti。此时系统会随机以
</code></pre>
<p>的概率进入关卡k。 </p>
<pre><code>3.Mingo是一个富有天赋的玩家，每一关都能轻松过关，但是每一关都会消耗她一个小时去过关。

Mingo想以最快的速度通关所有的关卡，但是她非常困惑到底如何分组才能使她尽可能的尽早通关所有关卡呢。你能帮她计算一下如何分组才能使她通关所有关卡所用时间的期望最小么。
</code></pre>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><pre><code>CF原题,第一次遇到的斜率dp,详解见B
</code></pre>
<h4 id="思考-7"><a href="#思考-7" class="headerlink" title="思考"></a>思考</h4><ul>
<li>这题后面我CF过了,但是scu一直过不了,可能因为我写错了,然后CF用相对误差,SCU用绝对误差</li>
</ul>
<h3 id="L-来签个到吧"><a href="#L-来签个到吧" class="headerlink" title="L 来签个到吧"></a>L 来签个到吧</h3><h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4><ul>
<li>给你 n (2 &lt;&#x3D; n &lt;&#x3D; 60,000) 个球,每球上都写有互不相同的数字t ( 0 &lt;&#x3D; t &lt; 100,000),这些球放在一个盒子里.开始你能执行一种加球操作:选择任意两个球: x 和y,然后看| x - y |在已经有的球中是否存在,如果不存在,就把|x - y|写在一个球上,把这个球加入这个盒子,这里就成功完成了一次加球操作.<br>你就一直加球,直到盒子中任意两个数的差,在集合中已经存在</li>
</ul>
<pre><code>现在摸求,问你摸完所有球的所进行操作次数的期望
</code></pre>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><ul>
<li><strong>最终状态会有多少个球?</strong></li>
</ul>
<pre><code>显然加球操作很像辗转相减的过程,我们只需要对这题求最大公约数,然后最大值除以这个最大公约数就是最终的个数
</code></pre>
<ul>
<li><strong>期望怎么求?</strong></li>
</ul>
<pre><code>如果当前摸过了i个球,还剩下n-i个就没有摸,那么摸到i+1球的期望是多少?

-    可以用无穷级数来求

-    可以感性认识一下,n 个球我要摸到n-i球中的一个期望是多少,就是n / (n-i)

所以最后ans = sum(n/i) + 加球操作数
</code></pre>
<h4 id="思考-8"><a href="#思考-8" class="headerlink" title="思考"></a>思考</h4><ul>
<li>这题要注意对0的处理</li>
<li>这题实际不难,但是读错题意,以为操作只包括摸球</li>
</ul>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第二场联合赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>easyproblem</title>
    <url>/2016/06/07/easyproblem/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>特工喵星人yoyo现在的任务是去解决N个目标人物，这N个人在不同的N个城市里面，这N个城市之间存在m条有向道路。现在yoyo不想自己出面，只派手下人去完成任务。基于某些特殊的原因，每个人不能往回走，但是每个城市可以经过无数次，所经过的城市的目标任务都会被解决掉。请输出需要的最少人数（可以从任何位置出发）。</p>
<span id="more"></span>


<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>最小路径覆盖板子题</p>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第三场联合赛</category>
      </categories>
      <tags>
        <tag>最小路径覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5730 Shell Necklace (16多校第一场fft+分治)</title>
    <url>/2016/08/06/hdu5730/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>$已知长度为n(1\leq n \leq 10^5)的序列{a _i}$<br>$给你n个贝壳,你可以把他分成m份,每份个数分别是b _1 ,b _2 , b _3 …b <em>m $<br>$ 那么你可以获得a</em>{b_1}  a _{b _2}  a _{b _3}…  a _{b _m} 的贡献值 ,现在问你所有不同分法的贡献值值和是多少 $</p>
</blockquote>
<span id="more"></span>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><blockquote>
<p>   设dp[i]为数量总共为i的所有不同分法的总贡献值<br>   $ dp[i+1] &#x3D; dp[i] \times a_1+dp[i-1] \times a_2 + dp[i-2] \times a_3+…+dp[1] \times a_i+a_{i+1} $<br>   $ dp[n] &#x3D; \sum_{i&#x3D;1} ^{n}dp[n-i]*a_i $<br>   具有多项式形式可以考虑fft，但是直接会T，考虑cdq分治，每次分治时跑fft即可</p>
</blockquote>
<p>其实具体为什么这样可以我都不是很清楚,附送两发fft学习链接<a href="http://wenku.baidu.com/view/8bfb0bd476a20029bd642d85.html">fft流程图</a>和<a href="http://wlsyzx.yzu.edu.cn/kcwz/szxhcl/kechenneirong/jiaoan/jiaoan3.htm">DFT原理</a>以及<a href="http://www.cnblogs.com/kuangbin/p/3210565.html">kuangbin博客</a></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//*************************************************************************</span></span><br><span class="line">    &gt; File Name: hdu5730.cpp</span><br><span class="line">    &gt; Author: liangxianfeng</span><br><span class="line">    &gt; Mail:   liangxianfeng96@qq.com</span><br><span class="line">    &gt; Created Time: <span class="number">2016</span>年<span class="number">07</span>月<span class="number">25</span>日 星期一 <span class="number">11</span>时<span class="number">27</span>分<span class="number">08</span>秒</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">typedef</span> complex&lt;<span class="type">double</span>&gt; cmx;</span><br><span class="line">cmx x[maxn], y[maxn];</span><br><span class="line"><span class="type">int</span> a[maxn], dp[maxn], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(cmx x[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = len/<span class="number">2</span>; i &lt; len<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(x[i], x[j]);</span><br><span class="line">        <span class="type">int</span> k = len/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= k)&#123;</span><br><span class="line">            j -= k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; k) j+= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(cmx x[], <span class="type">int</span> len, <span class="type">int</span> on)</span></span>&#123;</span><br><span class="line">    <span class="built_in">change</span>(x, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">cmx <span class="title">wn</span><span class="params">(cos(-on*<span class="number">2</span>*PI/i), sin(-on*<span class="number">2</span>*PI/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j += i)&#123;</span><br><span class="line">            <span class="function">cmx <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt; j + i/<span class="number">2</span>; ++k)&#123;</span><br><span class="line">                cmx u = x[k];</span><br><span class="line">                cmx v = x[k+i/<span class="number">2</span>]*w;</span><br><span class="line">                x[k] = u + v;</span><br><span class="line">                x[k+i/<span class="number">2</span>] = u-v;</span><br><span class="line">                w *= wn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(on == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            x[i] /= len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">313</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        dp[l] += a[l];</span><br><span class="line">        dp[l] %= MOD;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid);</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(len &lt;= (r-l+<span class="number">1</span>)) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,len) x[i] = y[i] = <span class="built_in">cmx</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= mid; ++i)&#123;</span><br><span class="line">        x[i-l] = <span class="built_in">cmx</span>(dp[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r-l; ++i)&#123;</span><br><span class="line">        y[i<span class="number">-1</span>] = <span class="built_in">cmx</span>(a[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fft</span>(x, len, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fft</span>(y, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        x[i] *= y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fft</span>(x, len, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = mid+<span class="number">1</span>; i &lt;= r; ++i)&#123;</span><br><span class="line">        dp[i] += (<span class="type">int</span>)(x[i-l<span class="number">-1</span>].<span class="built_in">real</span>() + <span class="number">0.5</span>);</span><br><span class="line">        dp[i] %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cdq</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="built_in">MEM</span>(dp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            a[i] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cdq</span>(<span class="number">1</span>, n);</span><br><span class="line">        cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学</category>
        <category>FFt</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>cdq</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用小结</title>
    <url>/2016/08/06/git%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<hr>
<h6 id="由于不经常使用git-经常忘记一些常用命令-而每次用的时候又是重新学习-这里记下一些常用方便以后使用"><a href="#由于不经常使用git-经常忘记一些常用命令-而每次用的时候又是重新学习-这里记下一些常用方便以后使用" class="headerlink" title="由于不经常使用git,经常忘记一些常用命令,而每次用的时候又是重新学习,这里记下一些常用方便以后使用"></a>由于不经常使用git,经常忘记一些常用命令,而每次用的时候又是重新学习,这里记下一些常用方便以后使用</h6><ul>
<li>git 本地添加远程仓库<ul>
<li>git remote add  origin <a href="mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>:zerolxf&#x2F;zero.git</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li><p>git更新子模块</p>
<ul>
<li>git submodule update</li>
</ul>
</li>
<li><p>创建分支</p>
<ul>
<li>git branch test</li>
</ul>
</li>
<li><p>hexo布置</p>
<ul>
<li>npm install hexo-deployer-git –save<br>hexo d</li>
</ul>
</li>
<li><p>hexo布置出问题了,就把deploy_git删掉</p>
</li>
</ul>
]]></content>
      <categories>
        <category>git使用小结</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON 格式转换成Java对象</title>
    <url>/2018/01/28/json2java/</url>
    <content><![CDATA[<h1 id="JSON-格式转换成Java对象"><a href="#JSON-格式转换成Java对象" class="headerlink" title="JSON 格式转换成Java对象"></a>JSON 格式转换成Java对象</h1><hr>
<span id="more"></span>
<p><a href="https://github.com/zerolxf/MyDemo">源代码</a><br>添加依赖到pom.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.6.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>需要转换的对象是<code>ObjectC</code>和<code>ObjectD</code>,其中<code>ObjectD</code>的一个成员变量是<code>List&lt;ObjectC&gt;</code>.<br>jackson能够递归转换,让json中包含json的这种也能够转为相应的Java对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ObjectC.java</span></span><br><span class="line"><span class="keyword">package</span> com.workstation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectC</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@JsonProperty</span> (<span class="string">&quot;Message&quot;</span>)</span><br><span class="line">	String message;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.message = message;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//JSON 中message也会绑定到message成员变量</span></span><br><span class="line">	<span class="meta">@JsonProperty</span> (<span class="string">&quot;message&quot;</span>)</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">_getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@JsonProperty</span> (<span class="string">&quot;message&quot;</span>)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.message = message;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所写，ObjectC对象和Json中的”Message”和”message”都绑定到了message成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ObjectD.java</span><br><span class="line">package com.workstation;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"></span><br><span class="line">public class ObjectD &#123;</span><br><span class="line"></span><br><span class="line">	List&lt;ObjectC&gt; list;</span><br><span class="line"></span><br><span class="line">	@JsonProperty (&quot;List&quot;)</span><br><span class="line">	public List&lt;ObjectC&gt; getList() &#123;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //能够像spring一样,自动完成ObjectC的转换</span><br><span class="line">	@JsonProperty (&quot;List&quot;)</span><br><span class="line">	public void setList(List&lt;ObjectC&gt; list) &#123;</span><br><span class="line">		this.list = list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.workstation;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonParseException;</span><br><span class="line">import com.fasterxml.jackson.core.type.TypeReference;</span><br><span class="line">import com.fasterxml.jackson.databind.JsonMappingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line">public class testJsonToObject &#123;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void test() throws JsonParseException, JsonMappingException, IOException &#123;</span><br><span class="line">		String jsonString = &quot;&#123;    \&quot;message\&quot;:\&quot;Hello World\&quot;&#125;&quot;;</span><br><span class="line">		ObjectC objectC = (new ObjectMapper()).readValue(jsonString, ObjectC.class);</span><br><span class="line">		System.out.println(objectC.getMessage());</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">//		&#123;</span><br><span class="line">//			&quot;List&quot;: [</span><br><span class="line">//			&#123;&quot;message&quot;:&quot;hello A&quot;&#125;,</span><br><span class="line">//			&#123;&quot;Message&quot;:&quot;hello B&quot;&#125;</span><br><span class="line">//			]</span><br><span class="line">//			&#125;</span><br><span class="line">		String jsonListString = &quot;&#123;\r\n&quot; + </span><br><span class="line">				&quot;\&quot;List\&quot;: [\r\n&quot; + </span><br><span class="line">				&quot;&#123;\&quot;message\&quot;:\&quot;hello A\&quot;&#125;,\r\n&quot; + </span><br><span class="line">				&quot;&#123;\&quot;Message\&quot;:\&quot;hello B\&quot;&#125;\r\n&quot; + </span><br><span class="line">				&quot;]\r\n&quot; + </span><br><span class="line">				&quot;&#125;&quot;;</span><br><span class="line">		ObjectD objectD = (new ObjectMapper()).readValue(jsonListString, ObjectD.class);</span><br><span class="line">		List&lt;ObjectC&gt; list = objectD.getList();</span><br><span class="line">		for(int i = 0; i &lt; list.size(); ++i) &#123;</span><br><span class="line">			System.out.println(list.get(i).getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//jackson结合TypeReference</span><br><span class="line">		Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">		map = (new ObjectMapper()).readValue(jsonString, new TypeReference&lt;Map&lt;String, String&gt;&gt;()&#123;&#125;);</span><br><span class="line">		for(Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">			System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">hello A</span><br><span class="line">hello B</span><br><span class="line">message:Hello World</span><br></pre></td></tr></table></figure>
<p>如上所示,jackson成功读取了含有list的json对象<br>jsackson还可以和TypeReference一起使用,这样对某些特定情况下就不用专门新建一个类来读取相关东西了</p>
]]></content>
      <tags>
        <tag>jackson java</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 安装必备</title>
    <url>/2016/11/09/list-md/</url>
    <content><![CDATA[<h3 id="Ubuntu初始化"><a href="#Ubuntu初始化" class="headerlink" title="Ubuntu初始化"></a>Ubuntu初始化</h3><h4 id="1-安装无线驱动和更新系统以及语言"><a href="#1-安装无线驱动和更新系统以及语言" class="headerlink" title="1. 安装无线驱动和更新系统以及语言"></a>1. 安装无线驱动和更新系统以及语言</h4><h4 id="2-安装新立得和gdebi"><a href="#2-安装新立得和gdebi" class="headerlink" title="2. 安装新立得和gdebi"></a>2. 安装新立得和gdebi</h4><p><code>sudo apt-get install synaptic</code></p>
<h4 id="3-安装软件"><a href="#3-安装软件" class="headerlink" title="3.安装软件"></a>3.安装软件</h4><p><code>sudo apt-get install git vim vim-gnome vim-gtk uget ariac</code></p>
<blockquote>
<p>这里用synaptic安装特别方便还不容易出事故</p>
</blockquote>
<span id="more"></span>
<h3 id="初始化github"><a href="#初始化github" class="headerlink" title="初始化github"></a>初始化github</h3><h4 id="1-安装ssh-key"><a href="#1-安装ssh-key" class="headerlink" title="1. 安装ssh key"></a>1. 安装ssh key</h4><h5 id="1-生成ssh-key"><a href="#1-生成ssh-key" class="headerlink" title="(1) 生成ssh key"></a>(1) 生成ssh key</h5><p><code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code></p>
<h5 id="（2）添加新的Key到ssh-agent"><a href="#（2）添加新的Key到ssh-agent" class="headerlink" title="（2）添加新的Key到ssh-agent"></a>（2）添加新的Key到ssh-agent</h5><p><code>eval &quot;$(ssh-agent -s)&quot;</code><br><code>ssh-add ~/.ssh/id_rsa</code></p>
<h5 id="3-添加到github"><a href="#3-添加到github" class="headerlink" title="(3) 添加到github"></a>(3) 添加到github</h5><h4 id="2-配置github信息"><a href="#2-配置github信息" class="headerlink" title="2. 配置github信息"></a>2. 配置github信息</h4><p><code>git config --global user.name &quot;Your Name&quot;</code><br><code>git config --global user.email &quot;your@email.com&quot;</code></p>
<h4 id="3-同步远端代码"><a href="#3-同步远端代码" class="headerlink" title="3. 同步远端代码"></a>3. 同步远端代码</h4><p><code>git remote add origin git@github.com:zerolxf/zero.git</code></p>
<h3 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h3><h4 id="1-shadowsocks安装"><a href="#1-shadowsocks安装" class="headerlink" title="1. shadowsocks安装"></a>1. shadowsocks安装</h4><p><code>sudo add-apt-repository ppa:hzwhuang/ss-qt5</code><br><code>sudo apt-get update</code><br><code>sudo apt-get install shadowsocks-qt5 </code></p>
<h4 id="2-proxychains安装"><a href="#2-proxychains安装" class="headerlink" title="2. proxychains安装"></a>2. proxychains安装</h4><p><code>sudo apt-get install proxychains</code></p>
<p>修改最后一行配置信息为socks5 127.0.0.1 1080<br><code>sudo vim /etc/proxychains.conf</code></p>
<h4 id="3-uget的安装："><a href="#3-uget的安装：" class="headerlink" title="3. uget的安装："></a>3. uget的安装：</h4><p><code>sudo add-apt-repository ppa:plushuang-tw/uget-stable</code><br><code>sudo apt-get update </code><br><code>sudo apt-get install uget</code></p>
<h4 id="4-aria2的安装："><a href="#4-aria2的安装：" class="headerlink" title="4. aria2的安装："></a>4. aria2的安装：</h4><p><code>sudo add-apt-repository ppa:t-tujikawa/ppa </code><br><code>sudo apt-get update </code><br><code>sudo apt-get install aria2</code></p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>bcloud<br>chorme<br>shadowsock<br>星际翻译<br>git<br>nodejs &amp; hexo<br>and so on<br>vim</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><h4 id="socks5-强转http"><a href="#socks5-强转http" class="headerlink" title="socks5 强转http"></a>socks5 强转http</h4><p><a href="http://www.cnblogs.com/liuxuzzz/p/5324749.html">privoxy</a></p>
<h4 id="淘宝镜像安装hexo"><a href="#淘宝镜像安装hexo" class="headerlink" title="淘宝镜像安装hexo"></a>淘宝镜像安装hexo</h4><p><a href="https://npm.taobao.org/">淘宝镜像</a></p>
<blockquote>
<p><del>nmp,nodejs直接用新立得安装</del><br>这里还是到<a href="https://nodejs.org/en/">nodejs官网</a>,直接下载压缩包,然后解压,把解压后的bin目录添加到PATH环境变量中去,记得PATH&#x3D;$PATH:xxx&#x2F;bin</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>meixiuxiu学图论</title>
    <url>/2016/06/07/meixiuxiu%E5%AD%A6%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>题目大意就是:问你这个图是否存在环,如果存在环,那么环的最小生成代价是多少</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.仿照最小生成树,但是一旦某一跳边的两个端点已经在一个并查集则答案就是当前边权值</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.刚开始并查集写搓了,没有x &#x3D; find(x);直接p[x] &#x3D; y;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: f.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月29日 星期日 20时09分50秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v, c;</span><br><span class="line">    <span class="built_in">Edge</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> _u, <span class="type">int</span> _v, <span class="type">int</span> _c)&#123;</span><br><span class="line">        u = _u;</span><br><span class="line">        v = _v;</span><br><span class="line">        c = _c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge&amp; rhs)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; rhs.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="type">int</span> edgenum;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> p[maxn], rank[maxn];</span><br><span class="line"><span class="type">int</span> t, n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] = (x==p[x]?x:<span class="built_in">find</span>(p[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) p[i] = i, rank[i] = <span class="number">1</span>, vis[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(rank[x] &gt; rank[y]) p[y] = x;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p[x] = y;</span><br><span class="line">        <span class="keyword">if</span>(rank[x] == rank[y]) rank[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> ans = INF, u, v, c;</span><br><span class="line">        edgenum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;c);</span><br><span class="line">            edge[edgenum++] = <span class="built_in">Edge</span>(u,v,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(edge, edge + edgenum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> u = edge[i].u, v = edge[i].v;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">unite</span>(u,v)) &#123;</span><br><span class="line">                ans = edge[i].c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == INF) <span class="built_in">printf</span>(<span class="string">&quot;No solution!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第三场联合赛</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>webbench学习</title>
    <url>/2018/01/28/webbench/</url>
    <content><![CDATA[<h1 id="开源代码学习"><a href="#开源代码学习" class="headerlink" title="开源代码学习"></a>开源代码学习</h1><p>无聊至极,学习一下一些简单的开源项目</p>
<h3 id="Webbench"><a href="#Webbench" class="headerlink" title="Webbench"></a>Webbench</h3><blockquote>
<p>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。 –by <a href="https://www.zhihu.com/question/26469623">林木</a></p>
</blockquote>
<!-- more -- >

#### 命令行参数解析
要看懂代码,最好先学习下`getopt_long`等函数的用法,他是c语言中用来解析命令行参数
分析一个很全的学习[博客1][2]和[博客2][3]
使用 getopt_long_only 时, - 和 --都可以作用于长选项, 而使用 getopt_only 时, 只有 --可以作用于长选项.
短选项:就是只是一个字符串如`-a -v`,只用-表示
长选项:一般如`--help --version`,在getopt_long_only中`-name`也是

`const char * optstring` optstring用来指定可以处理哪些选项
`"hvx:"`该示例表明程序可以接受3个选项: -h -v -x, 其中 x 后面的 :表示该选项后面要跟一个参数, 即如 -x 10的形式, 选项后面跟的参数会被保存到 optarg 变量中. 下面是一个使用示例
`extern int optind`  下一次调用getopt的时，从optind存储的位置处重新开始检查选项。 

#### 字符串处理函数
`strrchr()` 函数用于查找某字符在字符串中最后一次出现的位置，其原型为：
    `char * strrchr(const char *str, int c);`
    
`atoi` (表示ascii to integer)是把字符串转换成整型数的一个函数

`strncasecmp()`用来比较参数s1 和s2 字符串前n个字符，比较时会自动忽略大小写的差异

`strstr(str1,str2)` 函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL
`strchr`是计算机的一个函数，原型为extern char *strchr(const char *s,char c)，可以查找字符串s中首次出现字符c的位置

函数`char * index(const char *s, int c); `函数说明index()用来找出参数s 字符串中第一个出现的参数c 地址

### fork讲解
[fork讲解][5]
这个代码总共执行多少次？
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">   fork();</span><br><span class="line">   fork() &amp;&amp; fork() || fork();</span><br><span class="line">   fork();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;+/n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>20!</strong> fork返回值只有0，1<br>所以最终结果就是0&#x2F;1***0&#x2F;1,所以只需要分析中间3个合理组合，只有5个符合条件，所以5×4&#x3D;20</p>
<h3 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h3><p>这里有别人<a href="http://www.cnblogs.com/xuning/p/3888699.html">源代码分析</a></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>linux</category>
        <category>webbench</category>
      </categories>
      <tags>
        <tag>linux 开源</tag>
      </tags>
  </entry>
  <entry>
    <title>任务</title>
    <url>/2016/05/23/%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>有两台机器n个任务,每个任务i在机器A完成时间是a[i],B上面完成时间是b[i],任务i可以被处理当前仅当每个任务j(i&gt;j)已经被完成或者正在进行.求最少完成任务的时间(n&lt;2000,a[i],b[i]&lt;&#x3D;3000)<span id="more"></span></li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>首先读清楚题目意思</li>
</ul>
<pre><code>**任务i可以被处理当前仅当每个任务j(i&gt;j)已经被完成或者正在进行**

上面这句话有什么用?

仔细分析后可以发现上面这个性质确保了执行任意任务的时候机器AB时间差不会超过3000

假如A比B将少运行时间超过3000,那么现在放置任务i+1
-    那么任务i+1不能放置机器A最开始空闲的时候,因为这样B机器必然(B多A3000时间)有任务j(j&lt;i)还没有没执行;那么任务i+1只能当道B机器运行最后一个任务j的起始时间上去,这样的方案必然没有比任务j放置到A机器方案优(可以画图模拟一下)
-    把任务i+1放置到机器B,那么这种方案将继续造成恶性循环又进入此状态,显然最终这种方案不优

所以任一个任务选择的时候AB机器运行结束时间差不能够3000

**建立状态**

dp[i][j]表示完成任务i并且机器AB运行结束时间差为j的最少时间,(j&gt;0表示A比B多j,否则B比A多-j,后面右移3000,保证都是正数)

**状态转移**

dp[i][j]由dp[i-1][j+a[i]和dp[i-1][j-b[i]]转移过来,其中要注意任务i放到机器A或B中可能对时间没有影响
</code></pre>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li><strong>错误分析</strong></li>
</ul>
<pre><code>-    没有对非法状态进行限制,比如状态转移的时候,放置任务i到机器A,必须设定任务i时间当值 &gt;= B机器最后一个任务j放置时间!!!确保i之前的任务被处理完或正被处理
-    没有考虑任务i放置到机器A后对时间无影响的情况
</code></pre>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第二场联合赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>修长廊</title>
    <url>/2016/05/23/%E4%BF%AE%E9%95%BF%E5%BB%8A/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li><p>现在要修长廊覆盖n个点，第i个点可以单独修一个长廊，也可以修到前面第j个点（覆盖j到i之间的点），现在修i和j之间的长廊花费cost(i,j) &#x3D; W + (x $ _i  － x _j  )  ^{2} ,其中W是固有花费,现在求最小花费是多少 $</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
<li><p>我们状态很好建立,dp[i]表示覆盖到第i个点为止至少需要花费多少,但是他可以有很多状态转移过来.</p>
<pre><code>  dp[i] = min(dp[j-1]+cost(j,i));
</code></pre>
</li>
<li><p>如果现在有两个状态j和k(其中j&gt;k)可以转移过来.那么用单调队列dp思想把这两个相减</p>
<pre><code>     dp[j] + cost(j,i) - dp[k] - cost(k,i) 
      
   =(dp[j] +x[j]*x[j])-(dp[k]+ x[k]*x[k]) -　2*x[i]*(x[j]-x[k]) 
  
</code></pre>
<p>  那么也就是说如果dp[j]转移过来比dp[k]更优的话,就有上式小于 0,那么我们在更新最优的dp[y]的时候,如果前面存在一个状态x比状态i差,那么便有上式成立</p>
<p>  同时可以发现如果现在就已经成立,那么这个式子对y以后的状态都会成立,因为对y以后的x<a href="i%3E=y">i</a>上式也成立(这个就是斜率dp的特点,总会有一个自变量一直递增或递减),那么状态x就属于无用状态应该从队列中剔除</p>
<p>  <strong>判定条件一:如果i点没有j点优(也就是说j点比i点更优)的条件是i和j(i&lt;j)斜率小于2x[i]</strong></p>
</li>
<li><p>那么如何保证队列起第一个就是最优的呢?</p>
<ul>
<li><p><strong>感性的认识:</strong></p>
<ul>
<li><p>根据上面的式子我们可以一直判断第一个和第二个元素然后剔除,从而使得保证队队列第一个一定比第二个更优,那么剩下的就需要保证第一个比第三个,第一个比第四个更优…这个性质一直成立就好了</p>
</li>
<li><p>假设上面这个性质成立则有:23点的斜率大于12点,34点斜率大于12点…</p>
</li>
</ul>
</li>
</ul>
<p>  但是确保每相邻两个点斜率大于12点不具有<strong>传递性</strong>,所以我们可以缩小简化:23点的斜率大于12点,34点斜率大于23点…从而形成了<strong>下凸包</strong></p>
<pre><code>  *    从结果看:斜率递增保证了下凸包,而下凸包其实是保证了**:第三个点没有第二个点优,第四个点没有三个点优..**,因为第一个破坏下凸包性质的点一定不是最优,可参考理性认识的证明
  
  
</code></pre>
</li>
<li><p>所以我们要维护上面两个性质:1:第一个点比第二个点优,2:第三个点没有第二个点优,第四个点没有三个点优… <strong>(用维护斜率递增实现)</strong></p>
</li>
</ul>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>如何证明维护的队列的第一个就是最优的呢?<br>-    <strong>理性认识:</strong></li>
</ul>
<pre><code>$    dp[i] = dp[j] + x[j]  ^&#123;2&#125;  + x[i] ^&#123;2&#125; +　2x[i]*x[j] + W $
    
$    dp[i] - W - x[i] ^&#123;2&#125;  = dp[j] + x[j]  ^&#123;2&#125; +　2x[i]*x[j] $

    从上面这个式子看出dp[i] , $x[i] ^&#123;2&#125; ,$ Ｗ这三个相对于i是定值
    
-    **问题转换:**  我们要找到这样一个 x[j] 和 $dp[j] + x[j] ^&#123;2&#125; $使得 dp[i] 最小,看成b = y - kx,也就是b最小.从而我们可以画出一些点$(2*x[j],dp[j] + x[j] ^&#123;2&#125; )$,用斜率固定k的直线从下面往上面开始扫描,第一个接触到的点就是我们要找的最优点.这样找的话就会发现一个特点,上凸包的转折点永远不会被扫到,所以也应该剔除.

    如果我们在每一次插入的时候一直这样判断,那么就能够保证最后两个斜率一定大于前两个点的斜率,由于插入斜率大小具有**传递性**,所以能够保证**斜率递增**
    
    **但是光斜率递增就一定能够使得第一个最优吗?**
    
    -    确保第一个最优的充分必要条件是每个点和第一个点的斜率大于等于2x[i],这样看来显然不能够确保第一个最优.(**举一个极限的例子,所有点和第一个点的斜率都小于2x[i]但是却递增**)
    
-    为了**弥补**上面的不足,可以让第一个优于第二个,也就是12斜率大于2x[i],由于上面凸包的性质使得第一个点和所有点斜率都大于2x[i]也就是说,以后的点不能够比第一个点更优.所以:**第一个是最优的**
    
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: b.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月13日 星期五 16时20分14秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    ll num, x;</span><br><span class="line">    <span class="built_in">Node</span> ()&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(ll _num, ll _x)&#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll x[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Node&amp; a, <span class="type">const</span> Node &amp;b, <span class="type">const</span> ll&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.num - a.num &lt;= x*(b.x-a.x)*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get2</span><span class="params">(<span class="type">const</span> Node&amp; a, <span class="type">const</span> Node&amp; b, <span class="type">const</span> Node&amp; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b.num - a.num)*(c.x - a.x) &gt;= (c.num - a.num)*(b.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll w;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tail = <span class="number">-1</span>,head = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = w;</span><br><span class="line">        q[++tail] = <span class="built_in">Node</span>(x[<span class="number">1</span>]*x[<span class="number">1</span>], x[<span class="number">1</span>]);</span><br><span class="line">        q[++tail] = <span class="built_in">Node</span>(w+x[<span class="number">2</span>]*x[<span class="number">2</span>],x[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head &lt; tail &amp;&amp; <span class="built_in">get</span>(q[head], q[head+<span class="number">1</span>], x[i])) head++;</span><br><span class="line">            dp[i] = q[head].num + w + (x[i]*x[i]) - <span class="number">2</span>*x[i]*q[head].x;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i<span class="number">-1</span>] + w);</span><br><span class="line">            Node qnum = <span class="built_in">Node</span>(dp[i] + (x[i+<span class="number">1</span>]*x[i+<span class="number">1</span>]), x[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">while</span>(head &lt; tail &amp;&amp; <span class="built_in">get2</span>(q[tail<span class="number">-1</span>], q[tail], qnum)) tail--;</span><br><span class="line">            q[++tail] = qnum;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第二场联合赛</category>
      </categories>
      <tags>
        <tag>斜率dp</tag>
      </tags>
  </entry>
  <entry>
    <title>先锋看烟花</title>
    <url>/2016/05/24/%E5%85%88%E9%94%8B%E7%9C%8B%E7%83%9F%E8%8A%B1/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li><p>一共有n个地点（1到n排列），一共有m个烟花，每个烟花放出的地点ai和时间ti，每个烟花有观赏值bi，对于每个烟花，对先锋的幸福度贡献bi-|ai-cur|，其中cur表示放第i个烟花时先锋所处的位置，因此，当先锋离烟花太远时，幸福度甚至会下降！已知先锋每秒最多运动d距离，问这个晚上先锋看烟花能获得的最大幸福度。</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
<li><p>这相当于是一道移动接苹果的题目,只不过每秒移动范围为d并且烟花放的每一个点都有一个贡献值可为负数</p>
</li>
<li><p><strong>状态建立</strong></p>
</li>
</ul>
<pre><code>dp[i][j]表示第i个烟花位于j位置最多能够获得多少幸福感

**状态转移**

    dp[i][j]=min(dp[i-1][k]+bi-|ai-j|);
    
    k和j差值不超过(t[i] - t[i-1]) * d
    
**转移优化**

直接转移显然不行,那么就可以分成两种情况并进行单调队列优化了
若ai&gt;cur
    
    dp[i][j]=min(dp[i-1][k]+bi-ai+j);
那么维护一个和j差范围处于(t[i]-t[i-1])*d的队列

如果 dp[i-1][k] 和 dp[i-1][kk] 都在队列中并且 k &lt; k &amp;&amp;  dp[i-1][k] &lt; dp[i-1][kk] 那么在对i时刻烟花j以后的位置,都不会选择dp[i-1][k]了,因为dp[i-1][kk] 一定比他优,所以dp[i-1][k]这个状态就要从队列中间pop出来

所以队首的只要处于范围之内一定最优

这个队列最多插入n次pop n次,因而复杂度是O(n)
</code></pre>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>当遇到一种可以由很多种状态转移过来的时候,考虑一下nlogn线段树或树状数组查询或单调队列或斜率优化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: f.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月14日 星期六 19时37分51秒</span></span><br><span class="line"><span class="comment"> ********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">ll dp[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    ll num, pos;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(ll _num, ll _pos)&#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        pos = _pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line">ll b[maxn], a[maxn], t[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Node&amp; a, <span class="type">const</span> Node&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num &lt; b.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> kase, m, d;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;kase);</span><br><span class="line">    <span class="keyword">while</span>(kase--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d%d&quot;</span>, &amp;n, &amp;m, &amp;d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a[i], &amp;b[i], &amp;t[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="type">int</span> tail = <span class="number">-1</span>, head = <span class="number">0</span>;</span><br><span class="line">        ll ma = n, last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(now,pre);</span><br><span class="line">            ma = <span class="built_in">min</span>(n, (t[i] - last)*d+<span class="number">1</span>);</span><br><span class="line">            tail=<span class="number">-1</span>;head =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ma; ++j) &#123;</span><br><span class="line">                Node nw = <span class="built_in">Node</span>(dp[pre][j],j);</span><br><span class="line">                <span class="keyword">while</span>(head &lt;= tail &amp;&amp; <span class="built_in">get</span>(q[tail], nw)) tail--;</span><br><span class="line">                q[++tail] = nw;</span><br><span class="line">            &#125;</span><br><span class="line">            ma = (t[i] - last)*d;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j+ma&lt;=n) &#123;</span><br><span class="line">                    Node nw = <span class="built_in">Node</span>(dp[pre][j+ma], j+ma);</span><br><span class="line">                    <span class="keyword">while</span>(head &lt;= tail &amp;&amp; <span class="built_in">get</span>(q[tail], nw)) tail--;</span><br><span class="line">                    q[++tail] = nw;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(head &lt;= tail &amp;&amp; <span class="built_in">abs</span>(q[head].pos - j) &gt; ma) head++;</span><br><span class="line">                dp[now][j] = q[head].num + b[i] - <span class="built_in">abs</span>(a[i] - j);</span><br><span class="line">            &#125;</span><br><span class="line">            last = t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[now][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第二场联合赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>单调队列优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试与Spring</title>
    <url>/2018/01/28/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="单元测试与Spring框架"><a href="#单元测试与Spring框架" class="headerlink" title="单元测试与Spring框架"></a>单元测试与Spring框架</h1><p><a href="https://www.jianshu.com/p/1b04c698c56b">参考博客</a><br><a href="https://github.com/zerolxf/MyDemo">源代码</a></p>
<p>当进行单元测试的时候,需要给对象的依赖一个mock对象<br>但是对于Spring项目对象的私有成员,我们无法访问给他一个mock对象.这个时候我们就需要ReflectionTestUtils,他能够像Spring一样注入filed,通过手动给私有成员一个mock对象</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectA</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String pwString;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getPwString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> pwString;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPwString</span><span class="params">(String pwString)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.pwString = pwString;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>被测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectB</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ObjectA objectA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> ObjectA <span class="title function_">getObjectA</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> objectA;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObjectA</span><span class="params">(ObjectA objectA)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.objectA = objectA;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.util.ReflectionTestUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testMockito</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">ObjectB</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectB</span>();</span><br><span class="line">		<span class="type">ObjectA</span> <span class="variable">objectA</span> <span class="operator">=</span> mock(ObjectA.class);</span><br><span class="line">		when(objectA.getPwString()).thenReturn(<span class="string">&quot;hello A&quot;</span>);</span><br><span class="line">		<span class="comment">//&quot;objectA&quot;是通过成员变量名字确定的</span></span><br><span class="line">		ReflectionTestUtils.setField(objectB, <span class="string">&quot;objectA&quot;</span>, objectA);</span><br><span class="line">		</span><br><span class="line">		<span class="type">ObjectA</span> <span class="variable">actucalA</span> <span class="operator">=</span> objectB.getObjectA();</span><br><span class="line">		assertEquals(<span class="string">&quot;hello A&quot;</span>, actucalA.getPwString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>单元测试 mock</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试笔记</title>
    <url>/2018/01/28/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="单元测试-笔记"><a href="#单元测试-笔记" class="headerlink" title="单元测试 笔记"></a>单元测试 笔记</h1><p>学习链接<br><a href="http://static.javadoc.io/org.mockito/mockito-core/2.13.0/org/mockito/Mockito.html">Mockito官方文档</a><br><a href="http://wiki.jikexueyuan.com/list/java/">极客学院</a><br><a href="http://www.yiibai.com/testng/suite-test.html">TestNg</a><br><a href="http://www.cnblogs.com/Ming8006/p/6297333.html">Mockito中文教程</a></p>
<h2 id="Mockito-使用情景"><a href="#Mockito-使用情景" class="headerlink" title="Mockito 使用情景"></a>Mockito 使用情景</h2><p>我们往往会遇到要测试的类有很多依赖，这些依赖的类&#x2F;对象&#x2F;资源又有别的依赖，从而形成一个大的依赖树，要在单元测试的环境中完整地构建这样的依赖，是一件很困难的事情。</p>
<span id="more"></span>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">	ObjectB objectB = mock(ObjectB.class);</span><br><span class="line">	ObjectA objectA = new ObjectA();</span><br><span class="line">	objectA.setPwString(&quot;testString&quot;);</span><br><span class="line">	when(objectB.getObjectA()).thenReturn(objectA);</span><br><span class="line">	</span><br><span class="line">	ObjectA actucalA = objectB.getObjectA();</span><br><span class="line">	assertEquals(objectA, actucalA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意使用注释快速Mock的时候需要<code>MockitoAnnotations.initMocks(this);</code><a href="http://www.cnblogs.com/Ming8006/p/6297333.html">参考2.5</a></p>
<h3 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h3><p>在匹配方法的参数时候可以写准确值也可以使用any()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when(templateDAO.findAll(any(TemplateSpecification.class))).thenThrow(new </span><br><span class="line">	DataAccessException(&quot;query template failed&quot;) &#123;</span><br><span class="line">    	private static final long serialVersionUID = -6784264998739312988L;</span><br><span class="line">&#125;);</span><br><span class="line">when(templateDAO.findAll(any(TemplateSpecification.class))).thenThrow(new</span><br><span class="line">	DataAccessException(&quot;query template failed&quot;) &#123;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<ul>
<li>这里需要注意的是一旦参数使用了一个matcher,那么后面的参数都必须matcher</li>
<li>可以自己自定义参数匹配</li>
</ul>
<h3 id="doReturn-when-和when-doReturn-区别"><a href="#doReturn-when-和when-doReturn-区别" class="headerlink" title="doReturn().when()和when().doReturn()区别"></a>doReturn().when()和when().doReturn()区别</h3><p>这里需要注意一下<code>when().doReturn</code>和<code>doReturn().when()</code>的区别</p>
<ul>
<li>doReturn().when()不会真的去调用该方法</li>
<li>when().doReturn()在监测对象是完全mock对象的时候不会调用方法(因为mock就是一个假对象),而当对象是spy的时候会真的去调用该方法</li>
<li>当调用方法返回值是空的时候,只能用doReturn().when().method()</li>
</ul>
<h3 id="验证异常"><a href="#验证异常" class="headerlink" title="验证异常"></a>验证异常</h3><h4 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Rule</span><br><span class="line">public ExpectedException expectedEx = ExpectedException.none(); </span><br><span class="line">//...</span><br><span class="line">expectedEx.expect(CannotUploadTemplateException.class);</span><br><span class="line">expectedEx.expectMessage(&quot;Template Rejected&quot;); </span><br><span class="line">expectedEx.expect(CannotUploadTemplateException.class);</span><br><span class="line">expectedEx.expectMessage(&quot;Template Rejected&quot;); </span><br></pre></td></tr></table></figure>

<h4 id="使用注释来验证异常"><a href="#使用注释来验证异常" class="headerlink" title="使用注释来验证异常"></a>使用注释来验证异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(expected = RuntimeException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doThrow_when</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> mock(List.class);</span><br><span class="line">    doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(list).add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Spy检测对象"><a href="#Spy检测对象" class="headerlink" title="Spy检测对象"></a>Spy检测对象</h3><p>spy是一个可以检测实际对象的技术,能够监测方法并设置对象行为,这里就需要注意之前所说的<code> doReturn().when()</code>和<code>when().doReturn()</code>的区别,理解起来就是一种可实可虚的半mock对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">	ObjectB objectB = spy(new ObjectB());</span><br><span class="line">	ObjectA objectA = new ObjectA();</span><br><span class="line">	objectA.setPwString(&quot;testString&quot;);</span><br><span class="line">	when(objectB.getObjectA()).thenReturn(objectA);</span><br><span class="line">	</span><br><span class="line">	ObjectA actucalA = objectB.getObjectA();</span><br><span class="line">	assertEquals(objectA, actucalA);</span><br><span class="line">    //这里getValue()会调用实际的方法,返回值是&quot;hello world&quot;</span><br><span class="line">	assertEquals(&quot;hello world&quot;, objectB.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="重置Mock"><a href="#重置Mock" class="headerlink" title="重置Mock"></a>重置Mock</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Test</span><br><span class="line">public void reset_mock()&#123;</span><br><span class="line">    List list = mock(List.class);</span><br><span class="line">    when(list.size()).thenReturn(10);</span><br><span class="line">    list.add(1);</span><br><span class="line">    assertEquals(10,list.size());</span><br><span class="line">    //重置mock，清除所有的互动和预设</span><br><span class="line">    reset(list);</span><br><span class="line">    assertEquals(0,list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连续调用"><a href="#连续调用" class="headerlink" title="连续调用"></a>连续调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test(expected = RuntimeException.class)</span><br><span class="line">public void consecutive_calls()&#123;</span><br><span class="line">    //模拟连续调用返回期望值，如果分开，则只有最后一个有效</span><br><span class="line">    when(mockList.get(0)).thenReturn(0);</span><br><span class="line">    when(mockList.get(0)).thenReturn(1);</span><br><span class="line">    when(mockList.get(0)).thenReturn(2);</span><br><span class="line">    when(mockList.get(1)).thenReturn(0).thenReturn(1).thenThrow(new RuntimeException());</span><br><span class="line">    assertEquals(2,mockList.get(0));</span><br><span class="line">    assertEquals(2,mockList.get(0));</span><br><span class="line">    assertEquals(0,mockList.get(1));</span><br><span class="line">    assertEquals(1,mockList.get(1));</span><br><span class="line">    //第三次或更多调用都会抛出异常</span><br><span class="line">    mockList.get(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证执行顺序"><a href="#验证执行顺序" class="headerlink" title="验证执行顺序"></a>验证执行顺序</h3><p><a href="http://www.cnblogs.com/Ming8006/p/6297333.html">详情参考2.16</a></p>
<h3 id="确保模拟对象上无互动发生"><a href="#确保模拟对象上无互动发生" class="headerlink" title="确保模拟对象上无互动发生"></a>确保模拟对象上无互动发生</h3><p><a href="http://www.cnblogs.com/Ming8006/p/6297333.html">详情参考2.17</a></p>
<h3 id="找出冗余的互动-即未被验证到的"><a href="#找出冗余的互动-即未被验证到的" class="headerlink" title="找出冗余的互动(即未被验证到的)"></a>找出冗余的互动(即未被验证到的)</h3><p><a href="http://www.cnblogs.com/Ming8006/p/6297333.html">详情参考2.18</a></p>
]]></content>
      <categories>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>TestNg mockito</tag>
      </tags>
  </entry>
  <entry>
    <title>单词替换</title>
    <url>/2016/05/10/%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给出一个只包含小写字母的s字符串，和单词A,B。把s中的所有A替换成B，长度都小于5e6。PS:这题不需要考虑后效性</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.这题就是最裸的KMP，当s中匹配到A的时候把匹配到A的首位置标记一下，输出的时候直接跳过lenA的长度同时输出B就好</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.用KMP的时候一定要统一模板，以后就决定用f[0] &#x3D; 0, f[1] &#x3D; 0,这样的方式了，不需要纠结，也就不会有分歧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: b.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">    &gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2016年05月02日 星期一 20时41分52秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">char</span> s[maxn], t[maxn], ss[maxn];</span><br><span class="line"><span class="type">int</span> fs[maxn];</span><br><span class="line"><span class="type">int</span> lent, lens, lenss;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getfail</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> *fail)</span></span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    fail[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; lens; ++i)&#123;</span><br><span class="line">        j = fail[i];</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; str[i] != str[j]) j = fail[j];</span><br><span class="line">        fail[i+<span class="number">1</span>] = (str[i] == str[j]?j+<span class="number">1</span>:<span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">char</span> *T, <span class="type">char</span> *S, <span class="type">int</span> *fail)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lent; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; T[i] != S[j]) j = fail[j];</span><br><span class="line">        <span class="keyword">if</span>(T[i] == S[j]) ++j;</span><br><span class="line">        <span class="keyword">if</span>(j == lens)&#123;</span><br><span class="line">            T[i-lens+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printT</span><span class="params">(<span class="type">char</span>* T, <span class="type">char</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lent; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, b);</span><br><span class="line">            i+=lens<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span>  kase;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;kase);</span><br><span class="line">    <span class="keyword">while</span>(kase--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s%s&quot;</span>, t, s, ss);</span><br><span class="line">        lent = <span class="built_in">strlen</span>(t);</span><br><span class="line">        lens = <span class="built_in">strlen</span>(s);</span><br><span class="line">        lenss = <span class="built_in">strlen</span>(ss);</span><br><span class="line">        <span class="built_in">getfail</span>(s, fs);</span><br><span class="line">        <span class="built_in">find</span>(t, s, fs);</span><br><span class="line">        <span class="built_in">printT</span>(t, ss);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>又见背包</title>
    <url>/2016/05/24/%E5%8F%88%E8%A7%81%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li><p>有n种大小不同的数字a_i,每种m_i个，判断是否可以从这些数字中选出若干使它们的和恰好为k。(0&lt;n&lt;&#x3D;100,0&lt;k&lt;&#x3D;1e5)</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
<li><p><strong>建立状态</strong></p>
</li>
</ul>
<pre><code>dp[i][j]表示前i个物品能不能组成和是j
</code></pre>
<ul>
<li><strong>状态转移</strong></li>
</ul>
<pre><code>dp[i][j] |= dp[i-1][j-a[i]];
</code></pre>
<ul>
<li><strong>状态优化</strong></li>
</ul>
<pre><code>上面的状态首先可以二进制对个数进行优化,然后可以发现单独的一次转移居然只是转移一个bool,太浪费时间了,所以充分使用int或ll的位数,我们可以把j分成64位一组,一次性转移一组这样转移负责度就除以64了相当于降了两个数量级了

现在复杂度是n*k*logm/64,这样相当于消去logm而且转移过程还是位运算很快,所以就过了
</code></pre>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>如果以后遇到bool为dp存的状态的时候,那么这个状态肯定是不好的,这时候要么像这题一样压缩一下转移,要么重新建一个状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">	&gt; File Name: h.cpp</span><br><span class="line">	&gt; Author: liangxianfeng</span><br><span class="line">	&gt; Mail:   641587852@qq.com</span><br><span class="line">	&gt; Created Time: 2016年05月14日 星期六 00时14分48秒</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">#define rep(i,n) for(int i =0; i &lt; n; ++i)</span><br><span class="line">#define CLR(x) memset(x,0,sizeof x)</span><br><span class="line">#define MEM(a,b) memset(a,b,sizeof a)</span><br><span class="line">#define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br><span class="line">#define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt;  endl; </span><br><span class="line">const int maxn = 2e5+100;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int cnt[maxn], num[maxn];</span><br><span class="line">int kase, m;</span><br><span class="line">unsigned long long dp[maxn&gt;&gt;6];</span><br><span class="line">int a[100], b[100];</span><br><span class="line">int q[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">#ifdef LOCAL</span><br><span class="line">	freopen(&quot;/home/zeroxf/桌面/in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">#endif</span><br><span class="line">    int t, n;</span><br><span class="line">    ll k;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%lld&quot;, &amp;n, &amp;k);</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int p = 0;</span><br><span class="line">        for(int i= 0; i &lt; n; ++i)&#123;</span><br><span class="line">            ll base = a[i], cnt = 1;</span><br><span class="line">            while(cnt &lt;= b[i]) &#123;</span><br><span class="line">                if(cnt*base &lt;= k)&#123;</span><br><span class="line">                    q[p++] = cnt*base;</span><br><span class="line">                &#125;</span><br><span class="line">                b[i] -= cnt;</span><br><span class="line">                cnt&lt;&lt;=1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(b[i] &gt; 0 &amp;&amp; base*b[i] &lt;= k)&#123;</span><br><span class="line">                q[p++] = base*b[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int sz = (k&gt;&gt;6)+1;</span><br><span class="line">        memset(dp, 0, sizeof dp);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for(int i = 0; i &lt; p; ++i)&#123;</span><br><span class="line">            int x = q[i]&gt;&gt;6, y = q[i]&amp;63;</span><br><span class="line">            for(int j = 0; j &lt;= sz; ++j)&#123;</span><br><span class="line">                if(x+j&gt;sz) break;</span><br><span class="line">                dp[x+j] = dp[x+j] | (dp[j] &lt;&lt; y);</span><br><span class="line">                if(y) dp[x+j+1] = dp[x+j+1] | (dp[j] &gt;&gt; (64-y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int x = k &gt;&gt; 6, y = k&amp;63;</span><br><span class="line">        bool ok = false;</span><br><span class="line">        if(dp[x] &amp; (1&lt;&lt;y)) ok = true;</span><br><span class="line">        if(ok) printf(&quot;yes\n&quot;);</span><br><span class="line">        else printf(&quot;no\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>奶牛合影</title>
    <url>/2016/05/11/%E5%A5%B6%E7%89%9B%E5%90%88%E5%BD%B1/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>每个牛有一瑕疵值，我想再平移之后，得到一种排序他字典序最小，也就是最裸的最小表示法<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
</ul>
<ol>
<li><p>直接用模板</p>
</li>
<li><p>只要模板没有写错，几乎不会错</p>
</li>
</ol>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>没坑点</p>
</li>
<li><p>这题其实还可以用后缀数组写的，不过效率不划算</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: k.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月09日 星期一 12时47分03秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">6e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> s[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getminpos</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = len*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len; i &lt; l; ++i)&#123;</span><br><span class="line">        s[i] = s[i-len];</span><br><span class="line">    &#125;</span><br><span class="line">    s[l] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len &amp;&amp; j &lt; len &amp;&amp; k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i+k] == s[j+k]) k++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i+k] &lt; s[j+k]) &#123;</span><br><span class="line">            j = <span class="built_in">max</span>(i+<span class="number">1</span>,j+k+<span class="number">1</span>);</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> i = <span class="built_in">max</span>(j+<span class="number">1</span>,i+k+<span class="number">1</span>), k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; len) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">getminpos</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>,s[(i+ans)%n],(i==n<span class="number">-1</span>?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>最小表示法</tag>
      </tags>
  </entry>
  <entry>
    <title>双剑合并</title>
    <url>/2016/05/10/%E5%8F%8C%E5%89%91%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>n把A剑m把B剑，每一把剑都有一个值x，让A和B各自中的某一把剑的值异或，使得异或的值最大，输出此值。n和m不超过1e6,x不超过1e9</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.根据这题范围肯定需要O(n)级别算法，基本上就是固定A，然后B中的每一个值必须要在常数时间内找到最大对应的匹配的A的值。从这个限制描述，隐隐约约能够感觉到要用一个类似于字典树的东西。同时，基于一种贪心策略，尽可能的要让我合并后的值的最高位为1。所以，我们可以以最高位为根建一个深度为31的01二叉树，首先让A中的值一个一个插进去，并在相应节点标记为可走。那么B的某一个值只需要从根节点开始走，尽可能的走和自己不同的位的路(比如当前B的位是0,那么如果有1我就走1否则再走0)，这样能够保证走过的一定是最优的。</p>
<p>2.这题没啥可错的，做这题之前读了一片论文，所以很有帮助：浅谈信息学竞赛中的0和1by武森</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.这题写的比较撮，每一个都特判了一下，后面看到汝佳的伸展树感觉写法挺好的。ch[2],0表示左儿子，1表示右儿子，值为-1表示不存在。这样的话就不用讨论当前是0还是1了，用一个变量o表示x当前的01位，ch[o]如果不存在就!o就好</p>
<p>2.以后遇到两个数值变成最大，那么优先考虑高位。同时异或的性质比较好，可以预处理后很快求出i项和j项的异或和，同时还有一个特点sum[i]^sum[j]&#x3D;0 的话表明他们两个相等同时还表明第i项到第j项异或和是0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: a.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月02日 星期一 19时57分50秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> code[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="type">int</span> ans, sz;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> id, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> c = x &amp; (<span class="number">1</span>&lt;&lt;pos);</span><br><span class="line">    <span class="keyword">if</span>(c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[id].l == <span class="number">-1</span>) &#123;</span><br><span class="line">            node[id].l = sz++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(pos<span class="number">-1</span>, node[id].l, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[id].r == <span class="number">-1</span>)&#123;</span><br><span class="line">            node[id].r = sz++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(pos<span class="number">-1</span>, node[id].r, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> id, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; ans) ans = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c = x &amp; (<span class="number">1</span>&lt;&lt;pos);</span><br><span class="line">    <span class="keyword">if</span>(c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[id].r != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(pos<span class="number">-1</span>, node[id].r, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>((ans&amp;(<span class="number">1</span>&lt;&lt;pos)) &amp;&amp; ans &gt;= x) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(pos<span class="number">-1</span>, node[id].l, x^(<span class="number">1</span>&lt;&lt;pos));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[id].l != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(pos<span class="number">-1</span>, node[id].l, x^(<span class="number">1</span>&lt;&lt;pos));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>((ans&amp;(<span class="number">1</span>&lt;&lt;pos)) &amp;&amp; ans &gt;= x) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(pos<span class="number">-1</span>, node[id].r, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="type">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> n, m, t;</span><br><span class="line">    sz = maxn;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">            node[i].l = node[i].r = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">30</span>, <span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">30</span>, <span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>01异或</tag>
      </tags>
  </entry>
  <entry>
    <title>大小尾端</title>
    <url>/2018/01/28/%E5%A4%A7%E5%B0%8F%E5%B0%BE%E7%AB%AF/</url>
    <content><![CDATA[<h3 id="大小尾端"><a href="#大小尾端" class="headerlink" title="大小尾端"></a>大小尾端</h3><p>提到体系结构时，经常遇到大小尾端的概念，这里做个总结。<br>    big endian：大尾端，也称大端（高位）优先存储。<br>    little endian：小尾端，也称小端（低位）优先存储。<br>   如下00000000 00000000 00000000 00000001的存储</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大尾端： 00000000 00000000 00000000 00000001</span><br><span class="line">        addr+0    addr+1     addr+2   addr+3     //先存高有效位（在低地址）</span><br><span class="line">小尾端： 00000001 00000000 00000000 00000000</span><br><span class="line">        addr+0    addr+1     addr+2   addr+3     //先存低有效位（在低地址）</span><br></pre></td></tr></table></figure>
<p>故要判断机器的体系结构是大尾端还是小尾端，以下程序可以完成任务：</p>
<h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htons 把unsigned short类型从主机序转换到网络序</span><br><span class="line">htonl 把unsigned long类型从主机序转换到网络序</span><br><span class="line">ntohs 把unsigned short类型从网络序转换到主机序</span><br><span class="line">ntohl 把unsigned long类型从网络序转换到主机序</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.csdn.net/hellochenlu/article/details/50735407">参考博客</a></p>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>奶牛序列</title>
    <url>/2016/05/11/%E5%A5%B6%E7%89%9B%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>约翰刚帮奶牛们拍完照，拿着合影的他，看着奶牛队列，又莫名想到了一个字符串问题：<br>我们将n头奶牛的队列看成一个长为n的字符串S，让Ti表示从第i的字符开始的后缀。求：    <img src="http://7xread.com1.z0.glb.clouddn.com/3fd06cf9-7253-40fd-ad13-f076195d35e7" alt="图片描述"></li>
<li>其中，len(a)表示字符串a的长度，lcp(a,b)表示字符串a和字符串b的最长公共前缀，输入字符串长度不超过5e5<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
</ul>
<p>1. </p>
<ul>
<li><p>首先前面的len(Ti)和len(Tj)可以提取出来一步算出来，剩下主要就是求<br>lcp(Ti,Tj)的和，在后缀数组中求两个后缀的最长前缀长度，就是求各自对应h[i]数组间的最小值。由于这里i和j把所有的一对Ti和Tj组合都取遍，所以这里可以转换成求所有h[i]和h[j]数组中间的最小值的和的两倍</p>
</li>
<li><p>那么问题转换成求所有h[i]和h[j]数组中间的最小值的和，，如何快速的求出所有和呢，因为枚举会T。这里用到nlogn求最长公共子序列的思想。每一次我只求所有h[j]和h[i]之间的最小值的和(其中j&lt;i).</p>
</li>
<li><p>然后不断的放入h[i],h[i]放入到第一个大于等于他的位置并把当前位置的值更新为 h[i]（因为所有大于h[i]的h[j]的值在和h[i]取最小之后多出来的那部分无效了，即使是在求i之后h[k]的所有lcp和也一样，由于存在h[i],那么h[j]在h[i]的左边并大于h[i]的部分无效，所以就直接用h[i]代替了h[j]）.同在在那个位置记录下最新的位置信息pos[k] &#x3D; i。同时用一个数组sum[i]记录到位置i的lcp的和。</p>
</li>
<li><p>如何计算sum（lcp(Tj,Ti)） j&lt;i？，就拿h[i]插入后举例子，他的前一个h[i-1]一定小于h[i],那么那个位置的sum[i-1]就不需要更新了，直接拿来用。pos[i-1]和pos[i]之间的值就全部都是h[i]了，然后再更新sum[i].</p>
</li>
</ul>
<ol start="2">
<li>好了经过上面很长的分析之后，我忘记sum(lcp)*2了</li>
</ol>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>这题想到就不难了，当然实现的时候还是要想半天的</p>
</li>
<li><p>求最长公共子序列这种nlogn的思想很实用。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: l.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月05日 星期四 20时34分02秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">6e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> wa[maxn], wb[maxn], wv[maxn], c[maxn], t[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> *r, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a] == r[b] &amp;&amp; r[a+j] == r[b+j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSa</span><span class="params">(<span class="type">int</span> *r, <span class="type">int</span> *sa, <span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, p, *x = wa, *y = wb;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; ++i) c[x[i] = r[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i) c[i+<span class="number">1</span>] += c[i];</span><br><span class="line">    <span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) sa[--c[x[i]]] = i;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>, p = <span class="number">1</span>; p &lt; n; m = p, j &lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = n-j, p = <span class="number">0</span>; i &lt; n; i++) y[p++] = i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span>(sa[i] &gt;= j) y[p++] = sa[i] - j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) wv[i] = x[y[i]];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; ++i) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) c[wv[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i) c[i+<span class="number">1</span>] += c[i];</span><br><span class="line">        <span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) sa[--c[wv[i]]] = y[i];</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">        x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>, p = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            x[sa[i]] = <span class="built_in">cmp</span>(y, sa[i], sa[i<span class="number">-1</span>], j)?p<span class="number">-1</span>:p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rank[maxn], height[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getHeight</span><span class="params">(<span class="type">int</span> *r, <span class="type">int</span> *sa, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rank[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; height[rank[i++]] = k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j = sa[rank[i]<span class="number">-1</span>]; r[i+k] == r[j+k]; k++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ss[maxn];</span><br><span class="line"><span class="type">int</span> num[maxn];</span><br><span class="line"><span class="type">int</span> sa[maxn];</span><br><span class="line">ll a[maxn], pos[maxn];</span><br><span class="line">ll sum[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ss);</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(ss);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            num[i] = ss[i];</span><br><span class="line">        &#125;</span><br><span class="line">        num[len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getSa</span>(num, sa, len+<span class="number">1</span>, <span class="number">150</span>);</span><br><span class="line">        <span class="built_in">getHeight</span>(num, sa, len);</span><br><span class="line">        height[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; ++i) sum[i] = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">0</span>] = height[<span class="number">1</span>];</span><br><span class="line">        pos[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i = len; i &gt;= <span class="number">1</span>; --i) ans += (len<span class="number">-1</span>)*i;</span><br><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt;= len; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">lower_bound</span>(a,a+now,height[i]) - a;</span><br><span class="line">            <span class="keyword">if</span>(p==<span class="number">0</span>)&#123;</span><br><span class="line">                sum[<span class="number">0</span>] = (i<span class="number">-1</span>)*height[i];</span><br><span class="line">                ans -= <span class="number">2</span>*sum[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p &gt;= now) &#123;</span><br><span class="line">                sum[p] = sum[p<span class="number">-1</span>] + height[i];</span><br><span class="line">                ans -= <span class="number">2</span>*sum[p];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sum[p] =  sum[p<span class="number">-1</span>] + height[i]*(i-pos[p<span class="number">-1</span>]);</span><br><span class="line">                ans -= <span class="number">2</span>*(sum[p] );</span><br><span class="line">            &#125;</span><br><span class="line">            a[p] = height[i];</span><br><span class="line">            pos[p] = i;</span><br><span class="line">            now = p+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>奶牛情书 (ac自动机+dp)</title>
    <url>/2016/05/11/%E5%A5%B6%E7%89%9B%E6%83%85%E4%B9%A6/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>一个奶牛知道一些单词，现在有一个长度n的文本，问你这个文本至少包含一个奶牛会的单词的方案数。<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
</ul>
<ol>
<li></li>
</ol>
<ul>
<li><p>正向算至少包含一个太麻烦了，所以就逆向算，算出总的(快速幂取模)，再算出一个都不包含的情况。而怎么才能算出一个都不包含的情况呢。这个就涉及了自动机套dp。</p>
</li>
<li><p>方案数用到dp这个都能够想到，可是字符串如何用状态表示呢。这个就要用到前缀了，把每一个前缀看做一个状态，那么添加一个字符之后所形成的前缀成为了另外一种状态（这里需要注意的是空串也是一种特殊的前缀）。</p>
</li>
<li><p>但是怎么很快得到所有的前缀并能得到他们的转移方向呢，很简单，那就是ac自动机。他把每一个字符串的前缀都体现出来了，ac自动机的节点数就是这里的状态数，ac自动机另外也可以叫做<strong>有限状态机</strong>，状态就这样来了</p>
</li>
</ul>
<p>2. </p>
<ul>
<li>在禁止一些字符串时，少考虑了把包含这个字符串的其他前缀串都禁止了。比如aba和ccabac，我们现在要把这两个串禁止用，但是单禁止这两个串还不行，因为我们的一个前缀状态是ccaba,ccaba就包含了禁止串，所以我们要这样禁止一个串：如果他的失配后指向的串被禁止了那么当前的串也要禁止。    if(cnt[fail[u]]) cnt[u] &#x3D; 1;</li>
</ul>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>只要懂了原理就很简单了，没有坑点</p>
</li>
<li><p>这个类型的ac自动机加dp帮我更好理解自动机。之前对于ac自动机的根节点和fail数组并不是很理解，现在想就是root节点就是空节点。fail指针就相当于在这个节点添加一个字符匹配失配后我还能够匹配哪里。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>奶牛硬盘</title>
    <url>/2016/05/11/%E5%A5%B6%E7%89%9B%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>硬盘的制造商认为”一千” 是1000，但是操作系统认为”一千”是1024.单位分别有“B”, “KB”, “MB”, “GB”, “TB”, “PB”, “EB”, “ZB”, “YB” <span id="more"></span></li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol>
<li>很简单的一道题，只和单位有关系和前面数值没关系，先求出保存率，然后1-保存率，base[0]&#x3D; 1, base[1] &#x3D; （1000）&#x2F;1024;…</li>
</ol>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol>
<li>我在想0MB的丢失百分比是多少？？？我反正没考虑直接过了</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: m.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月09日 星期一 13时15分32秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">double</span> ans[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000</span>];</span><br><span class="line">string sz[]=&#123;<span class="string">&quot;B&quot;</span>, <span class="string">&quot;KB&quot;</span>, <span class="string">&quot;MB&quot;</span>, <span class="string">&quot;GB&quot;</span>, <span class="string">&quot;TB&quot;</span>, <span class="string">&quot;PB&quot;</span>, <span class="string">&quot;EB&quot;</span>, <span class="string">&quot;ZB&quot;</span>, <span class="string">&quot;YB&quot;</span>&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t, kase = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">1000.0</span>/<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">9</span>; ++i)&#123;</span><br><span class="line">        ans[i] = ans[i<span class="number">-1</span>]*ans[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>) l = i;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;]&#x27;</span>) r = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l+<span class="number">1</span>; i &lt; r; ++i)&#123;</span><br><span class="line">            str += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str == sz[i]) pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %.2f%\n&quot;</span>, ++kase,(<span class="number">100.0</span> - ans[pos]*<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>简单题</tag>
      </tags>
  </entry>
  <entry>
    <title>小冰和小娜</title>
    <url>/2016/05/11/%E5%B0%8F%E5%86%B0%E5%92%8C%E5%B0%8F%E5%A8%9C/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>这题就是一个车有方向的放在某一个位置，现在转向和前进都会消耗一点时间，问你从起点到达终点的最短时间<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4></li>
</ul>
<ol>
<li><p>这题就是我E题说到的，带附加属性的最短路，这个附加属性范围大小是4（4个方向）。那么直接在原先最短路的基础上面增加一维方向就好，然后就从初状态跑最短路就好。</p>
</li>
<li><p>当时写的太挫了，wa了几发，太粗心了</p>
</li>
</ol>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>没啥坑点</p>
</li>
<li><p>在状态转移的时候使用dx[i],dy[i],dd[i].这样三种操作弄成一个循环了简洁不出错</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: i.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月04日 星期三 19时57分47秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> dis[<span class="number">55</span>][<span class="number">55</span>][<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">char</span> mp[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, d, c;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _x, <span class="type">int</span> _y, <span class="type">int</span> _d, <span class="type">int</span> _c)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">        y = _y;</span><br><span class="line">        c = _c;</span><br><span class="line">        d = _d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; ++l)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; ++k)&#123;</span><br><span class="line">                    dis[i][j][l][k] = INF;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    dis[y][x][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(x,y,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> nx, ny, nc, nd;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        Node u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">6</span>; ++i)&#123;</span><br><span class="line">            nd = (u.d+i)%<span class="number">4</span>;</span><br><span class="line">            nx = u.x + dx[nd];</span><br><span class="line">            ny = u.y + dy[nd];</span><br><span class="line">            nc = (u.c+<span class="number">1</span>)%<span class="number">5</span>;</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">4</span>) &#123;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[u.y][u.x][nd][u.c] &gt; dis[u.y][u.x][u.d][u.c]+<span class="number">1</span>)&#123;</span><br><span class="line">                   dis[u.y][u.x][nd][u.c] = dis[u.y][u.x][u.d][u.c]+<span class="number">1</span>;</span><br><span class="line">                   q.<span class="built_in">push</span>(<span class="built_in">Node</span>(u.x,u.y,nd,u.c));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= m || ny &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp[ny][nx] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">if</span>(dis[ny][nx][nd][nc] &gt; dis[u.y][u.x][u.d][u.c] + <span class="number">1</span> + temp)&#123;</span><br><span class="line">                dis[ny][nx][nd][nc] = dis[u.y][u.x][u.d][u.c] + <span class="number">1</span> + temp;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(nx,ny,nd,nc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            <span class="type">int</span> x = INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; ++l)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; ++k)&#123;</span><br><span class="line">                    x = <span class="built_in">min</span>(x, dis[i][j][l][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x!=INF)&#123;</span><br><span class="line">                <span class="built_in">pr</span>(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">pr</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="type">int</span> sx,sy,ex,ey;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">                    sx = j; sy = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j] == <span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">                    ex = j;ey = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>(sx,sy);</span><br><span class="line">        <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="comment">//    print();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, dis[ey][ex][i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; INF) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找fly的真迹</title>
    <url>/2016/06/07/%E5%AF%BB%E6%89%BEfly%E7%9A%84%E7%9C%9F%E8%BF%B9/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>一个字符串S1S2S3S4…Sn，这个字符串只由字符”a”，”b”和”c”构成,为这个字符串画一张图.<br>1.它有n个点，从1到n进行标号。<br>2.对于图上任意的两个点i和j(i ≠ j)，当两者代表的字符在字典序顺序上相邻或者相等的时候，会被连上一条边。也就是说，”a”-“b”, “a”-“a”这类的，它们间会有一条边相连，而”a”-“c”这类的就没有边相连。</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.如果两个点没有连接边,那么必然是a和c点,那么取补图的情况下一个联通块,假设第一个是a,那么其他就都确定了,继续处理第二个联通块,就这样贪心之后,在把答案放到原图看是否冲突,得出就是答案</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.不知道为啥这样贪心就行…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: c.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">    &gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">    &gt; Created Time: 2016年05月29日 星期日 13时16分44秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> edgenum, head[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v, nxt;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[edgenum].nxt = head[u];</span><br><span class="line">    edge[edgenum].v = v;</span><br><span class="line">    head[u] = edgenum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">510</span>], in[<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> flag[<span class="number">510</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">MEM</span>(flag,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">MEM</span>(cnt,<span class="number">0</span>);</span><br><span class="line">    edgenum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    flag[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = edge[i].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">if</span>(flag[v] == <span class="number">-1</span>)&#123;</span><br><span class="line">                flag[v] = flag[u]^<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag[v] == flag[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            vis[u][v] = <span class="literal">true</span>;</span><br><span class="line">            vis[v][u] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j||vis[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">addedge</span>(i,j);</span><br><span class="line">                cnt[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i] != <span class="number">-1</span> || cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ok = ok &amp;&amp; <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(vis[i][j] &amp;&amp; flag[i] != flag[j])&#123;</span><br><span class="line">                    ok = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第三场联合赛</category>
      </categories>
      <tags>
        <tag>玄学</tag>
      </tags>
  </entry>
  <entry>
    <title>联合第一场</title>
    <url>/2016/05/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%90%9C%E7%B4%A2%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>n把A剑m把B剑，每一把剑都有一个值x，让A和B各自中的某一把剑的值异或，使得异或的值最大，输出此值。n和m不超过1e6,x不超过1e9</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.根据这题范围肯定需要O(n)级别算法，基本上就是固定A，然后B中的每一个值必须要在常数时间内找到最大对应的匹配的A的值。从这个限制描述，隐隐约约能够感觉到要用一个类似于字典树的东西。同时，基于一种贪心策略，尽可能的要让我合并后的值的最高位为1。所以，我们可以以最高位为根建一个深度为31的01二叉树，首先让A中的值一个一个插进去，并在相应节点标记为可走。那么B的某一个值只需要从根节点开始走，尽可能的走和自己不同的位的路(比如当前B的位是0,那么如果有1我就走1否则再走0)，这样能够保证走过的一定是最优的。</p>
<p>2.这题没啥可错的，做这题之前读了一片论文，所以很有帮助：浅谈信息学竞赛中的0和1by武森</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.这题写的比较撮，每一个都特判了一下，后面看到汝佳的伸展树感觉写法挺好的。ch[2],0表示左儿子，1表示右儿子，值为-1表示不存在。这样的话就不用讨论当前是0还是1了，用一个变量o表示x当前的01位，ch[o]如果不存在就!o就好</p>
<p>2.以后遇到两个数值变成最大，那么优先考虑高位。同时异或的性质比较好，可以预处理后很快求出i项和j项的异或和，同时还有一个特点sum[i]^sum[j]&#x3D;0 的话表明他们两个相等同时还表明第i项到第j项异或和是0</p>
<h3 id="B-单词替换"><a href="#B-单词替换" class="headerlink" title="B.单词替换"></a>B.单词替换</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给出一个只包含小写字母的s字符串，和单词A,B。把s中的所有A替换成B，长度都小于5e6。PS:这题不需要考虑后效性</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>1.这题就是最裸的KMP，当s中匹配到A的时候把匹配到A的首位置标记一下，输出的时候直接跳过lenA的长度同时输出B就好</p>
<h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h4><p>1.用KMP的时候一定要统一模板，以后就决定用f[0] &#x3D; 0, f[1] &#x3D; 0,这样的方式了，不需要纠结，也就不会有分歧</p>
<h3 id="C-01的时间"><a href="#C-01的时间" class="headerlink" title="C 01的时间"></a>C 01的时间</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给你一个数x，让你找到x的倍数，同时这个倍数只能包含01数字(十进制)，输出最小的符合条件的</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>1.这题本意是想让我们用搜索的，但写过数位dp后对这题第一反应就是可以dp啊。<br>dp[i][j][0]表示当前i长度余j并且第i位取0可不可达，同理dp[i][j][1]。</p>
<p>首先预处理出当第i位是1时对x取模的余数状态转移的话<br>*dp[i][j][0] |&#x3D; dp[i-1][j][0] || dp[i-1][j][1];<br>dp[i][j][1] |&#x3D; dp[i-1][(j-base[j]+x)%x][0] || dp[i-1][(j-base[j]+x)%x][1]; *</p>
<p>2.全部切记初始化0,dp[0][0][0] &#x3D; 1;</p>
<h4 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h4><p>1.这里刚开始我把dp所存的值弄混淆了，存了当前的最小值是多少，同时还开了一个辅助flag作为标记能不能可达。但是，后面想一想，完全没必要。因为当状态转移好之后，第一个首位是1并且取余是0的状态就是最小的(这个可以反向想一下)。找到最小的状态之后，剩下的就是往回找，看前一个是由谁转移来的。</p>
<p>2.前面的转移式是最基本的转移，但实际转移中为了回溯更方便可以dp记录上一位的取值情况，不可到达初始为-1. 当有两种可选的状态的时候选较小的。</p>
<p>3.我曾经错误以为：上述过程有一个性质就是，对于所找到的第一个符合条件首位是1的数字，他的之前所有状态都只有一个前述状态。为什么？假如他可以由两个状态转移y,z转移过来，那么(y-z)%x&#x3D;&#x3D;0,那么就会出现一个比当前更小的符合条件的。但是后面想一想（y-z）可能不符合只含01这个条件。（但是如果没有这个限制的话，这就是一个可以利用的性质）</p>
<h3 id="E-RunningPhoton’s-Nightmare"><a href="#E-RunningPhoton’s-Nightmare" class="headerlink" title="E.RunningPhoton’s Nightmare"></a>E.RunningPhoton’s Nightmare</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>一个人站在S这个起始位置，想要走到一个迷宫出口E，但是现在这个人身上有一个炸弹在k时间内就会爆炸，同时到达一些R位置能够让炸弹计时器清零，问能否出迷宫，能并输出最短时间,其中迷宫大小不超过600*600，1&lt;&#x3D;k&lt;&#x3D;600，最多有100个清零器</p>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>1.在S起点距离k的位置内的所有的都是可达并且最优时间等于最短距离。然后再由这些已经确定是最短的并且炸弹时间已被清零的点来更新周围距离k的点（如果炸弹时间不清零，那么这个点所能够到达的最远距离只能够在S的范围之内…）,然后这就好比是dijstra算法，只是多了一个限制（只能由R点更新周围点）。</p>
<p>2.刚开始拿到这一题想的是从起点开始暴搜（受到华为那个寻路比赛影响），状态包含当前已经走过的时间和炸弹剩余的时间以及当前位置，但是这样的话什么样的状态才是最优的就不好确定了，如果k小的话倒是能够对每个位置的每一个炸弹时间k记录一个最优时间。但是k比较大…</p>
<h4 id="思考-3"><a href="#思考-3" class="headerlink" title="思考"></a>思考</h4><p>1.上述算法最终只有S，E，R这三个点起作用了，那么现在就只看这三个点。如果这三类点距离小于k那么表示可以联通，也就是在原图的基础上面重新建了一个图。那就无脑跑100多次bfs求最短路，如果三类点距离d小于k则他们建一个d距离的边否则不能直接相连。</p>
<p>2.为了代码美观好写，用bfs求最短路的时候传入距离数组指针。</p>
<h3 id="F-表达式"><a href="#F-表达式" class="headerlink" title="F 表达式"></a>F 表达式</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>最快多少次才能够最快的得到$x^k$，可以从已经得到的数中乘除，最初只有x，比如 $x^31$,他最快可以通过通过6次操作</p>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>1.为了能够知道当前搜索的解x是最优解，那么我能够做的就只有把比x小的解全部枚举一遍。所以就用到迭代加深搜索。</p>
<p>2.刚拿到这题，有很多种贪心策略，可惜后面发现都不对。然后试着用最短路的姿势来写，不过问题是你怎么才能确认这是最短路。这个搜索的空间无穷大，所以一直搜下去永远不能够确定。但这个就告诉我们不能把搜索空间弄的太深因为这样容易在某一个解空间里面无限搜下去，同时我们还要能确保当前搜到某一个解一定是最优解。由此，迭代加深搜索就凸现出来了</p>
<h4 id="思考-4"><a href="#思考-4" class="headerlink" title="思考"></a>思考</h4><p>1.对这类搜索复杂度一直很迷。而且有一个细节问题一直不能理解，为什么搜的时候一定要从当前最新的值a和前面的值进行运算得到新的值，而不能是以前的值b和c得出d，然后d和a再得出我想要的值呢？</p>
<p>2.搜的时候可以保留记录。以后对这类迷糊不确定上界的搜索首先就想到迭代加深吧！！！</p>
<h3 id="G-神舟的宝藏"><a href="#G-神舟的宝藏" class="headerlink" title="G 神舟的宝藏"></a>G 神舟的宝藏</h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>让你找这样一个密码：</p>
<ul>
<li>密码是一个C进制的数； </li>
<li>密码由给定的M个数字构成；</li>
<li>密码是一个给定N的十进制整数的正整数倍；</li>
<li>如果存在多个满足上面所有条件的数字，值最小数字就是密码； </li>
<li>系统输入上限为500位数字，如果求出的密码长度大于500位，则也不能打开房门。</li>
</ul>
<p>其中C，M不超过16，N不超过5000</p>
<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><ol>
<li><p>这题相当于01的时间的<strong>进阶版</strong>。写起来就很简单了：我们预处理的时候要以C进制为基础预处理第i为是M个数字中的某一个是对N取模的余数是多少。dp[i][j]表示长度为i，对N余数是j这样状态第i位是哪一个数字</p>
</li>
<li><p>这题和之前的有两个不一样是</p>
</li>
</ol>
<ul>
<li>我不确定0有没有，如果有0的话我要特殊判断当前是0.状态转移的时候从最小数值开始转移**(当余数j是0的时候不包含0，因为这个时候如果能用其他数值更新那么后面就不需要再添加数字了，如果用0更新的话就会出现前导0还需要继续添加位数这样就不是最小的)**，就能够保证后面得到相同状态的时候值最小。</li>
<li>状态使用dp[i][j]而不像C题那样使用dp[i][j][k]多出来的K表示当前位取第K个数字，这样的添加了状态数和转移数，使得转移复杂度变得高很多，内存也不划算</li>
</ul>
<h4 id="思考-5"><a href="#思考-5" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>像上面所说的那样从最小数字更新，这样一旦更新了，我就不准二次更新了，不需要比较值了，这样dp就可以“安心”记录上一个状态的值了</p>
</li>
<li><p>这题容易处理错0这个数字，如果更新的时候把0放在最先，那么dp[i][0]永远都只会被0更新，而这是非法的（就好比是00000000…）。如果不把0放到最前面，那么处理余数非0的状态时候明可以用0来更新，而被用非0数字更新这样会导致所求的不是最小的数值。</p>
</li>
</ol>
<h3 id="H-DNA序列"><a href="#H-DNA序列" class="headerlink" title="H. DNA序列"></a>H. DNA序列</h3><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><ul>
<li>就是让你找这样一个字符串，让所给的串是目标串的子串，那么目标串最短应该是多少 （最多8个串，每个串长度最大为5）</li>
</ul>
<h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><ol>
<li><p>这个题我只用了迭代加深搜索，但是没剪枝过了，数据没卡我（AAAA GGGG CCCCC TTTTT就T了）。后面想了一下状态压缩记忆化搜索是可以在有限时间搜索出来的。用8个六进制的数字表示每一个串的当前位置。然后这个状态只有四种转移方向ATGC，然后从最终状态往前记忆化搜索就好了。</p>
</li>
<li><p>搜索一直没想出来怎么剪枝…,所以就使用迭代加深思想，然后暴力的枚举8个队列串首字符，比如枚举当前字符为A，那么谁队首是A的就POP出来，如果没有队首是A那就没必要搜索了。</p>
</li>
</ol>
<h4 id="思考-6"><a href="#思考-6" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>没啥坑点，就是不好好剪枝你会T在上面那个样例</p>
</li>
<li><p>在用状态压缩转移的时候，要用记忆化从最后搜，因为最初状态往后转移的话，初状态不好枚举。</p>
</li>
</ol>
<h3 id="I-小冰和小娜"><a href="#I-小冰和小娜" class="headerlink" title="I. 小冰和小娜"></a>I. 小冰和小娜</h3><h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><ul>
<li>这题就是一个车有方向的放在某一个位置，现在转向和前进都会消耗一点时间，问你从起点到达终点的最短时间</li>
</ul>
<h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><ol>
<li><p>这题就是我E题说到的，带附加属性的最短路，这个附加属性范围大小是4（4个方向）。那么直接在原先最短路的基础上面增加一维方向就好，然后就从初状态跑最短路就好。</p>
</li>
<li><p>当时写的太挫了，wa了几发，太粗心了</p>
</li>
</ol>
<h4 id="思考-7"><a href="#思考-7" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>没啥坑点</p>
</li>
<li><p>在状态转移的时候使用dx[i],dy[i],dd[i].这样三种操作弄成一个循环了简洁不出错</p>
</li>
</ol>
<h3 id="J-TooEasy-Or-TooDifficult"><a href="#J-TooEasy-Or-TooDifficult" class="headerlink" title="J. TooEasy Or TooDifficult"></a>J. TooEasy Or TooDifficult</h3><h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4><ul>
<li>给你定义两类值，P[i]表示以第i个字符为中心的最长回文串长度，MZ和max{P[i]}有关，FJD为连续若干个P[i]异或和的最大值。问你MZ和FJD谁大</li>
</ul>
<h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><ol>
<li><p>解决MZ就是最裸的manacher算法，FJD则利用到一个性质sum[j]^sum[i] &#x3D; p[i]^…P[j];这样转换之后就是求最大的sum[j]^sum[i],这个问题在问题A中谈论过了，就是建立01二叉树，然后把sum[i]全部插入，再全部走一遍</p>
</li>
<li><p>当时生成插入01树的时候写挫了，一直死循环，debug半天</p>
</li>
</ol>
<h4 id="思考-8"><a href="#思考-8" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>没啥坑点</p>
</li>
<li><p>常规题</p>
</li>
</ol>
<h3 id="K-奶牛合影"><a href="#K-奶牛合影" class="headerlink" title="K. 奶牛合影"></a>K. 奶牛合影</h3><h4 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h4><ul>
<li>每个牛有一瑕疵值，我想再平移之后，得到一种排序他字典序最小，也就是最裸的最小表示法</li>
</ul>
<h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><ol>
<li><p>直接用模板</p>
</li>
<li><p>只要模板没有写错，几乎不会错</p>
</li>
</ol>
<h4 id="思考-9"><a href="#思考-9" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>没坑点</p>
</li>
<li><p>这题其实还可以用后缀数组写的，不过效率不划算</p>
</li>
</ol>
<h3 id="L-奶牛序列"><a href="#L-奶牛序列" class="headerlink" title="L. 奶牛序列"></a>L. 奶牛序列</h3><h4 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h4><ul>
<li>约翰刚帮奶牛们拍完照，拿着合影的他，看着奶牛队列，又莫名想到了一个字符串问题：<br>我们将n头奶牛的队列看成一个长为n的字符串S，让Ti表示从第i的字符开始的后缀。求：    <img src="http://7xread.com1.z0.glb.clouddn.com/3fd06cf9-7253-40fd-ad13-f076195d35e7" alt="图片描述"></li>
<li>其中，len(a)表示字符串a的长度，lcp(a,b)表示字符串a和字符串b的最长公共前缀，输入字符串长度不超过5e5</li>
</ul>
<h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>1. </p>
<ul>
<li><p>首先前面的len(Ti)和len(Tj)可以提取出来一步算出来，剩下主要就是求<br>lcp(Ti,Tj)的和，在后缀数组中求两个后缀的最长前缀长度，就是求各自对应h[i]数组间的最小值。由于这里i和j把所有的一对Ti和Tj组合都取遍，所以这里可以转换成求所有h[i]和h[j]数组中间的最小值的和的两倍</p>
</li>
<li><p>那么问题转换成求所有h[i]和h[j]数组中间的最小值的和，，如何快速的求出所有和呢，因为枚举会T。这里用到nlogn求最长公共子序列的思想。每一次我只求所有h[j]和h[i]之间的最小值的和(其中j&lt;i).</p>
</li>
<li><p>然后不断的放入h[i],h[i]放入到第一个大于等于他的位置并把当前位置的值更新为 h[i]（因为所有大于h[i]的h[j]的值在和h[i]取最小之后多出来的那部分无效了，即使是在求i之后h[k]的所有lcp和也一样，由于存在h[i],那么h[j]在h[i]的左边并大于h[i]的部分无效，所以就直接用h[i]代替了h[j]）.同在在那个位置记录下最新的位置信息pos[k] &#x3D; i。同时用一个数组sum[i]记录到位置i的lcp的和。</p>
</li>
<li><p>如何计算sum（lcp(Tj,Ti)） j&lt;i？，就拿h[i]插入后举例子，他的前一个h[i-1]一定小于h[i],那么那个位置的sum[i-1]就不需要更新了，直接拿来用。pos[i-1]和pos[i]之间的值就全部都是h[i]了，然后再更新sum[i].</p>
</li>
</ul>
<ol start="2">
<li>好了经过上面很长的分析之后，我忘记sum(lcp)*2了</li>
</ol>
<h4 id="思考-10"><a href="#思考-10" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>这题想到就不难了，当然实现的时候还是要想半天的</p>
</li>
<li><p>求最长公共子序列这种nlogn的思想很实用。</p>
</li>
</ol>
<h3 id="M-奶牛硬盘"><a href="#M-奶牛硬盘" class="headerlink" title="M. 奶牛硬盘"></a>M. 奶牛硬盘</h3><h4 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h4><ul>
<li>硬盘的制造商认为”一千” 是1000，但是操作系统认为”一千”是1024.单位分别有“B”, “KB”, “MB”, “GB”, “TB”, “PB”, “EB”, “ZB”, “YB”</li>
</ul>
<h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><ol>
<li>很简单的一道题，只和单位有关系和前面数值没关系，先求出保存率，然后1-保存率，base[0]&#x3D; 1, base[1] &#x3D; （1000）&#x2F;1024;…</li>
</ol>
<h4 id="思考-11"><a href="#思考-11" class="headerlink" title="思考"></a>思考</h4><ol>
<li>我在想0MB的丢失百分比是多少？？？我反正没考虑直接过了</li>
</ol>
<h3 id="N-奶牛情书"><a href="#N-奶牛情书" class="headerlink" title="N. 奶牛情书"></a>N. 奶牛情书</h3><h4 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h4><ul>
<li>一个奶牛知道一些单词，现在有一个长度n的文本，问你这个文本至少包含一个奶牛会的单词的方案数。</li>
</ul>
<h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><ol>
<li></li>
</ol>
<ul>
<li><p>正向算至少包含一个太麻烦了，所以就逆向算，算出总的(快速幂取模)，再算出一个都不包含的情况。而怎么才能算出一个都不包含的情况呢。这个就涉及了自动机套dp。</p>
</li>
<li><p>方案数用到dp这个都能够想到，可是字符串如何用状态表示呢。这个就要用到前缀了，把每一个前缀看做一个状态，那么添加一个字符之后所形成的前缀成为了另外一种状态（这里需要注意的是空串也是一种特殊的前缀）。</p>
</li>
<li><p>但是怎么很快得到所有的前缀并能得到他们的转移方向呢，很简单，那就是ac自动机。他把每一个字符串的前缀都体现出来了，ac自动机的节点数就是这里的状态数，ac自动机另外也可以叫做<strong>有限状态机</strong>，状态就这样来了</p>
</li>
</ul>
<p>2. </p>
<ul>
<li>在禁止一些字符串时，少考虑了把包含这个字符串的其他前缀串都禁止了。比如aba和ccabac，我们现在要把这两个串禁止用，但是单禁止这两个串还不行，因为我们的一个前缀状态是ccaba,ccaba就包含了禁止串，所以我们要这样禁止一个串：如果他的失配后指向的串被禁止了那么当前的串也要禁止。    if(cnt[fail[u]]) cnt[u] &#x3D; 1;</li>
</ul>
<h4 id="思考-12"><a href="#思考-12" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>只要懂了原理就很简单了，没有坑点</p>
</li>
<li><p>这个类型的ac自动机加dp帮我更好理解自动机。之前对于ac自动机的根节点和fail数组并不是很理解，现在想就是root节点就是空节点。fail指针就相当于在这个节点添加一个字符匹配失配后我还能够匹配哪里。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>层次分解位置编码 (Hierarchical Decomposition of Position Encoding)</title>
    <url>/2023/08/08/%E5%B1%82%E6%AC%A1%E5%88%86%E8%A7%A3%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%20(Hierarchical%20Decomposition%20of%20Position%20Encoding)/</url>
    <content><![CDATA[<h1 id="层次分解位置编码-Hierarchical-Decomposition-of-Position-Encoding"><a href="#层次分解位置编码-Hierarchical-Decomposition-of-Position-Encoding" class="headerlink" title="层次分解位置编码 (Hierarchical Decomposition of Position Encoding)"></a>层次分解位置编码 (Hierarchical Decomposition of Position Encoding)</h1><p>论文标题: 层次分解位置编码，让BERT可以处理超长文本<br>作者: 苏剑林<br>时间: 2020-12-04<br>核心算法名: 层次分解位置编码<br>论文链接: <a href="https://spaces.ac.cn/archives/7947">https://spaces.ac.cn/archives/7947</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>BERT模型最多能处理512个token的文本。这一瓶颈的根本原因是BERT使用了从随机初始化训练出来的绝对位置编码，一般的最大位置设为了512，因此顶多只能处理512个token，多出来的部分就没有位置编码可用了。另一个重要的原因是Attention的$O(n^2)$复杂度，导致长序列时显存用量大大增加，一般显卡也finetune不了。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>如何简单修改当前最大长度为512的BERT模型，使得它可以直接处理更长的文本。主要思路是层次分解已经训练好的绝对位置编码，使得它可以延拓到更长的位置。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>解决这个问题的一个主流思路是换成相对位置编码，这是个可行的办法，华为的NEZHA模型便是一个换成了相对位置编码的BERT模型。相对位置编码一般会对位置差做个截断，使得要处理的相对位置都在一个有限的范围内，因此相对位置编码可以不受限于序列长度。</p>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><ol>
<li>层次分解已经训练好的绝对位置编码，使得它可以延拓到更长的位置。具体来说，假设已经训练好的绝对位置编码向量为$p_1,p_2,…,p_n$，我们希望能在此基础上构造一套新的编码向量$q_1,q_2,…,q_m$，其中$m &gt; n$。为此，我们设<ul>
<li>$q_{(i-1)×n + j} &#x3D; αu_i + (1 - α)u_j$ 其中$α∈ (0, 1)$且$α ≠ 0.5$是一个超参数，$u_1,u_2,…,u_n$是该套位置编码的“基底”。这样的表示意义很清晰，就是将位置$(i - 1)×n + j$层次地表示为$(i, j)$，然后$i, j$对应的位置编码分别为$αu_i$和$(1 - α)u_j$，而最终$(i - 1)×n + j$的编码向量则是两者的叠加。</li>
<li>$u_i &#x3D; \frac{p_i - αp_1}{1 - α}$，$i &#x3D; 1,2,…,n$ 这样一来，我们的参数还是$p_1,p_2,…,p_n$，但我们可以表示出$n^2$个位置的编码，并且前$n$个位置编码跟原来模型是相容的。</li>
</ul>
</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li>和其他工作一个典型工作的方法区别是什么: 与使用相对位置编码的方法不同，这种方法是在已经训练好的绝对位置编码的基础上进行层次分解，使得它可以延拓到更长的位置，而不需要重新训练模型。</li>
<li>效果对比: 实验验证了这种方法的有效性，它可以使BERT模型处理更长的文本。</li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型 Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>打造更强大的Transformer - Google</title>
    <url>/2023/08/08/%E6%89%93%E9%80%A0%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84Transformer%20-%20Google/</url>
    <content><![CDATA[<h1 id="打造更强大的Transformer-Google"><a href="#打造更强大的Transformer-Google" class="headerlink" title="打造更强大的Transformer - Google"></a>打造更强大的Transformer - Google</h1><p>文章作者：苏剑林，发布时间：2020-04-13，核心算法名：Low-Rank Bottleneck in Multi-head Attention Models &amp; Talking-Heads Attention，文章链接：<a href="https://spaces.ac.cn/archives/7325">https://spaces.ac.cn/archives/7325</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自《Attention is All You Need》一文发布后，基于Multi-Head Attention的Transformer模型开始流行起来，而去年发布的BERT模型更是将Transformer模型的热度推上了又一个高峰。然而，技术的探索是无止境的，改进的工作也相继涌现：有改进预训练任务的，比如XLNET的PLM、ALBERT的SOP等；有改进归一化的，比如Post-Norm向Pre-Norm的改变，以及T5中去掉了Layer Norm里边的beta参数等；也有改进模型结构的，比如Transformer-XL等；有改进训练方式的，比如ALBERT的参数共享等。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>以上的这些改动，都是在Attention外部进行改动的，也就是说它们都默认了Attention的合理性，没有对Attention本身进行改动。而本文我们则介绍关于两个新结果：它们针对Multi-Head Attention中可能存在建模瓶颈，提出了不同的方案来改进Multi-Head Attention。</p>
<span id="more"></span>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>两篇论文都来自Google，并且做了相当充分的实验，因此结果应该是相当有说服力的了。</p>
<h2 id="核心方法和步骤"><a href="#核心方法和步骤" class="headerlink" title="核心方法和步骤"></a>核心方法和步骤</h2><ol>
<li><p>第一个结果来自文章《Low-Rank Bottleneck in Multi-head Attention Models》，它明确地指出了Multi-Head Attention里边的表达能力瓶颈，并提出通过增大key_size的方法来缓解这个瓶颈。</p>
<ul>
<li>1.1 Multi-Head Attention的基础是自然是Single-Head Attention，也叫Scaled-Dot Attention，定义如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Attention(Q,K,V) = softmax(QK^T / sqrt(d_k))V</span><br></pre></td></tr></table></figure></li>
<li>1.2 在这里，Q、K、V分别是query、key、value，它们都是由输入X经过线性变换得到的，即Q&#x3D;XW_q，K&#x3D;XW_k，V&#x3D;XW_v。其中，W_q、W_k、W_v是待学习的参数矩阵，d_k是key的维度（也就是key_size）。</li>
</ul>
</li>
<li><p>第二个结果来自文章《Talking-Heads Attention》，这篇论文虽然没有显式地指出它跟前一篇论文的联系，但笔者认为它们事实上在解决同一个问题，只不过思路不一样：它指出当前的Multi-Head Attention每个head的运算是相互孤立的，而通过将它们联系（Talking）起来，则可以得到更强的Attention设计，即标题的“Talking-Heads Attention”。</p>
<ul>
<li>2.1 从单一分布到混合分布<ul>
<li>2.1.1 在前一篇论文里边，我们提到了低秩瓶颈，也就是由于key_size太小所以QK^T表达能力不足，因此softmax之后无法很好地建议完整的二元分布。为了缓解这个问题，除了增大key_size之外，还有没有其他方法呢？有，比如这篇论文使用的混合分布思路。</li>
<li>2.1.2 所谓混合分布，就是多个简单分布的叠加（比如加权平均），它能极大地增强原分布的表达能力。典型的例子是高斯混合模型：我们知道高斯分布只是一个常见的简单分布，但多个高斯分布叠加而成的高斯混合分布（也叫高斯混合模型，GMM）就是一个更强的分布，理论上来说，只要叠加的高斯分布足够多，高斯混合分布能逼近任意概率分布。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="工作对比"><a href="#工作对比" class="headerlink" title="工作对比"></a>工作对比</h2><ul>
<li>两篇论文都来自Google，并且做了相当充分的实验，因此结果应该是相当有说服力的了。再小也不能小key_size的第一个结果来自文章《Low-Rank Bottleneck in Multi-head Attention Models》，它明确地指出了Multi-Head Attention里边的表达能力瓶颈，并提出通过增大key_size的方法来缓解这个瓶颈。</li>
<li>第二个结果来自文章《Talking-Heads Attention》，这篇论文虽然没有显式地指出它跟前一篇论文的联系，但笔者认为它们事实上在解决同一个问题，只不过思路不一样：它指出当前的Multi-Head Attention每个head的运算是相互孤立的，而通过将它们联系（Talking）起来，则可以得到更强的Attention设计，即标题的“Talking-Heads Attention”。</li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型 Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建博客感想</title>
    <url>/2016/04/16/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<h1 id="搭建一个博客好麻烦"><a href="#搭建一个博客好麻烦" class="headerlink" title="搭建一个博客好麻烦"></a>搭建一个博客好麻烦</h1><p>… 不过我是直接复制别人主题的 ..</p>
]]></content>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>投票</title>
    <url>/2016/06/07/%E6%8A%95%E7%A5%A8/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>现在yoyo所在班级要选一个班长出来，每个同学可以投不止一张的票。有个约定，A同学投了B，B同学投了C，那么C就相当于获得了两张票，也就是说这中投票具有传递性。求最高票数，并输出那些同学获得了最高票数，从小到大。<span id="more"></span></li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.首先第一步反向建边然后缩点,就是一个无环图了,这时候感觉再跑一边tarjan,每个点结束时候dfnnum序减去最初进来的时候dfnnum差值就是这联通块投票数,不过这里dfnnum每次加上联通块所包含点的个数而不是加一</p>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路(最短路+网络流)</title>
    <url>/2016/06/07/%E6%9C%80%E7%9F%AD%E8%B7%AF(%E6%9C%80%E7%9F%AD%E8%B7%AF+%E7%BD%91%E7%BB%9C%E6%B5%81)/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>大概意思就是问你最短路有多少条</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.首先跑一边最短路,把之后的可行边保留下来建一个流为1的网络流图,再跑一边网络流就好</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.没啥坑点</p>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第三场联合赛</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>来签个到吧 (期望dp)</title>
    <url>/2016/05/24/%E6%9D%A5%E7%AD%BE%E4%B8%AA%E5%88%B0%E5%90%A7/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><ul>
<li>给你 n (2 &lt;&#x3D; n &lt;&#x3D; 60,000) 个球,每球上都写有互不相同的数字t ( 0 &lt;&#x3D; t &lt; 100,000),这些球放在一个盒子里.开始你能执行一种加球操作:选择任意两个球: x 和y,然后看| x - y |在已经有的球中是否存在,如果不存在,就把|x - y|写在一个球上,把这个球加入这个盒子,这里就成功完成了一次加球操作.<br>你就一直加球,直到盒子中任意两个数的差,在集合中已经存在</li>
</ul>
<pre><code>现在摸求,问你摸完所有球的所进行操作次数的期望
</code></pre>
<span id="more"></span>    
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li><strong>最终状态会有多少个球?</strong></li>
</ul>
<pre><code>显然加球操作很像辗转相减的过程,我们只需要对这题求最大公约数,然后最大值除以这个最大公约数就是最终的个数
</code></pre>
<ul>
<li><strong>期望怎么求?</strong></li>
</ul>
<pre><code>如果当前摸过了i个球,还剩下n-i个就没有摸,那么摸到i+1球的期望是多少?

-    可以用无穷级数来求

-    可以感性认识一下,n 个球我要摸到n-i球中的一个期望是多少,就是n / (n-i)

所以最后ans = sum(n/i) + 加球操作数
</code></pre>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>这题要注意对0的处理</li>
<li>这题实际不难,但是读错题意,以为操作只包括摸球</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*************************************************************************</span><br><span class="line">	&gt; File Name: l.cpp</span><br><span class="line">	&gt; Author: liangxianfeng</span><br><span class="line">	&gt; Mail:   641587852@qq.com</span><br><span class="line">	&gt; Created Time: 2016年05月14日 星期六 02时01分00秒</span><br><span class="line"> ************************************************************************/</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">#define rep(i,n) for(int i =0; i &lt; n; ++i)</span><br><span class="line">#define CLR(x) memset(x,0,sizeof x)</span><br><span class="line">#define MEM(a,b) memset(a,b,sizeof a)</span><br><span class="line">#define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br><span class="line">#define prln(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt;  endl; </span><br><span class="line">const int maxn = 4e5+100;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">#ifdef LOCAL</span><br><span class="line">	freopen(&quot;/home/zeroxf/桌面/in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">#endif</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        double ans = 0;</span><br><span class="line">        int b = 0, x;</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">            if(a[i] &gt; b) b = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        x = b;</span><br><span class="line">        bool ok = true;</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            if(a[i] == 0) &#123;</span><br><span class="line">                ok = false;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            x = __gcd(x, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int num = b/x;</span><br><span class="line">        if(!ok) num++;</span><br><span class="line">        ans = num-n;</span><br><span class="line">        for(int i = 1; i &lt;= num; ++i)&#123;</span><br><span class="line">            ans = ans +num*1.0/i;</span><br><span class="line">        &#125;</span><br><span class="line">        int temp = ans;</span><br><span class="line">        printf(&quot;%d\n&quot;,temp);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>玛雅好简单(tarjan求桥)</title>
    <url>/2016/06/07/%E7%8E%9B%E9%9B%85%E5%A5%BD%E7%AE%80%E5%8D%95(%E6%A1%A5)/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给你一个图,要你输出无向图桥的数目</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>直接上模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: i.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月29日 星期日 14时25分30秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> dfn[maxn], low[maxn];</span><br><span class="line"><span class="type">int</span> head[maxn];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> dfnnum, edgenum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v, nxt;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[edgenum].nxt = head[u];</span><br><span class="line">    edge[edgenum].v = v;</span><br><span class="line">    head[u] = edgenum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> in[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> fa, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++dfnnum;</span><br><span class="line">    low[u] = dfn[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; ~i; i = edge[i].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(in[i]) <span class="keyword">continue</span>;</span><br><span class="line">        in[i^<span class="number">1</span>] = in[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(i|<span class="number">1</span>,v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u])&#123; </span><br><span class="line">                 ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">MEM</span>(head,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">MEM</span>(dfn,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">MEM</span>(in,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">MEM</span>(vis,<span class="number">0</span>);</span><br><span class="line">    edgenum = <span class="number">0</span>;</span><br><span class="line">    dfnnum  = <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t, n, m;</span><br><span class="line">    <span class="type">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="type">int</span> u, v, root;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">addedge</span>(u,v);</span><br><span class="line">            <span class="built_in">addedge</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(<span class="number">-1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>,++kase);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第三场联合赛</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>神舟的宝藏</title>
    <url>/2016/05/11/%E7%A5%9E%E8%88%9F%E7%9A%84%E5%AE%9D%E8%97%8F/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>让你找这样一个密码：</p>
<ul>
<li>密码是一个C进制的数； </li>
<li>密码由给定的M个数字构成；</li>
<li>密码是一个给定N的十进制整数的正整数倍；</li>
<li>如果存在多个满足上面所有条件的数字，值最小数字就是密码； </li>
<li>系统输入上限为500位数字，如果求出的密码长度大于500位，则也不能打开房门。</li>
</ul>
<p>其中C，M不超过16，N不超过5000</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol>
<li><p>这题相当于01的时间的<strong>进阶版</strong>。写起来就很简单了：我们预处理的时候要以C进制为基础预处理第i为是M个数字中的某一个是对N取模的余数是多少。dp[i][j]表示长度为i，对N余数是j这样状态第i位是哪一个数字</p>
</li>
<li><p>这题和之前的有两个不一样是</p>
</li>
</ol>
<ul>
<li>我不确定0有没有，如果有0的话我要特殊判断当前是0.状态转移的时候从最小数值开始转移**(当余数j是0的时候不包含0，因为这个时候如果能用其他数值更新那么后面就不需要再添加数字了，如果用0更新的话就会出现前导0还需要继续添加位数这样就不是最小的)**，就能够保证后面得到相同状态的时候值最小。</li>
<li>状态使用dp[i][j]而不像C题那样使用dp[i][j][k]多出来的K表示当前位取第K个数字，这样的添加了状态数和转移数，使得转移复杂度变得高很多，内存也不划算</li>
</ul>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol>
<li><p>像上面所说的那样从最小数字更新，这样一旦更新了，我就不准二次更新了，不需要比较值了，这样dp就可以“安心”记录上一个状态的值了</p>
</li>
<li><p>这题容易处理错0这个数字，如果更新的时候把0放在最先，那么dp[i][0]永远都只会被0更新，而这是非法的（就好比是00000000…）。如果不把0放到最前面，那么处理余数非0的状态时候明可以用0来更新，而被用非0数字更新这样会导致所求的不是最小的数值。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: g.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月04日 星期三 17时29分57秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">550</span>][<span class="number">5500</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">550</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> t, n, m, c;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        num[<span class="number">1</span>][i] = a[i]%n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">500</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            num[i][j] = num[i<span class="number">-1</span>][j]*c%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i)&#123;</span><br><span class="line">        s[i] = i+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">10</span>) s[i] = <span class="string">&#x27;A&#x27;</span> + i<span class="number">-10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">char</span> ss[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;c, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ss);</span><br><span class="line">            <span class="keyword">if</span>(ss[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; ss[<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span>) a[i] = ss[<span class="number">0</span>] -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i] = ss[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a,a+m);</span><br><span class="line">        a[m] = a[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">getnum</span>(m,n);</span><br><span class="line">        <span class="type">int</span> len = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[k] == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i<span class="number">-1</span>][(j+n-num[i][k])%n] != <span class="number">-1</span> &amp;&amp; dp[i][j] == <span class="number">-1</span>)&#123;</span><br><span class="line">                        dp[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span>(j==<span class="number">0</span>) ok = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>&amp;&amp;a[<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][(j+n-num[i][<span class="number">0</span>])%n] != <span class="number">-1</span> &amp;&amp; dp[i][j] == <span class="number">-1</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ok) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ok) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>, pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">0</span>] != <span class="number">-1</span> &amp;&amp; a[dp[i][<span class="number">0</span>]] != <span class="number">0</span>)&#123;</span><br><span class="line">                ans = dp[i][<span class="number">0</span>];</span><br><span class="line">                pos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;BOMB!!!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &gt; <span class="number">0</span> &amp;&amp; ans != <span class="number">-1</span>)&#123;</span><br><span class="line">            ans = dp[pos][l];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, s[a[ans]]);</span><br><span class="line">            l = (l-num[pos][ans]+n)%n;</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式</title>
    <url>/2016/05/11/%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>最快多少次才能够最快的得到$x^k$，可以从已经得到的数中乘除，最初只有x，比如 $x^31$,他最快可以通过通过6次操作</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.为了能够知道当前搜索的解x是最优解，那么我能够做的就只有把比x小的解全部枚举一遍。所以就用到迭代加深搜索。</p>
<p>2.刚拿到这题，有很多种贪心策略，可惜后面发现都不对。然后试着用最短路的姿势来写，不过问题是你怎么才能确认这是最短路。这个搜索的空间无穷大，所以一直搜下去永远不能够确定。但这个就告诉我们不能把搜索空间弄的太深因为这样容易在某一个解空间里面无限搜下去，同时我们还要能确保当前搜到某一个解一定是最优解。由此，迭代加深搜索就凸现出来了</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>1.对这类搜索复杂度一直很迷。而且有一个细节问题一直不能理解，为什么搜的时候一定要从当前最新的值a和前面的值进行运算得到新的值，而不能是以前的值b和c得出d，然后d和a再得出我想要的值呢？</p>
<p>2.搜的时候可以保留记录。以后对这类迷糊不确定上界的搜索首先就想到迭代加深吧！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: f.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月05日 星期四 17时16分25秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> des, depth;</span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; depth) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[pos] == des) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos == depth) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[pos] == des;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ma = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt;= pos; ++i) if(a[i] &gt; ma) ma = a[i];</span></span><br><span class="line">    <span class="keyword">if</span>(((a[pos] )&lt;&lt; (depth-pos)) &lt; des)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= pos; ++i)&#123;</span><br><span class="line">        a[pos+<span class="number">1</span>] = a[pos] - a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[pos+<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ok = <span class="built_in">dfs</span>(pos+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok) <span class="keyword">return</span> ok;</span><br><span class="line">        a[pos+<span class="number">1</span>] = a[i] + a[pos];</span><br><span class="line">        <span class="keyword">if</span>(a[pos+<span class="number">1</span>] &gt; <span class="number">2</span>*des+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ok = <span class="built_in">dfs</span>(pos+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ok) <span class="keyword">return</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> n, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; ++i)&#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">   dis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">if</span>(dis[n] &lt; INF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[n]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nn = n;</span><br><span class="line">        <span class="keyword">while</span>(nn) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            nn&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        pos = <span class="built_in">max</span>(pos<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = pos;; ++i) &#123;</span><br><span class="line">            des = n;</span><br><span class="line">            depth = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                dis[n] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第一场联合赛</category>
      </categories>
      <tags>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title>雷神之路</title>
    <url>/2016/05/23/%E9%9B%B7%E7%A5%9E%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>在一个坐标轴上面起始位置是0，你可以往右走一步，两步，三步。其中某些位置不能走，问你走到位置n有多少种方法（1&lt;&#x3D; n &lt;&#x3D; 1e18）</p>
<span id="more"></span>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>这题是走楼梯的进阶版，状态很好想dp[n]，转移有三种：走一步两步三步转移过来。不过由于n太大，很容易想到矩阵加速。</li>
<li>用矩阵A表示第i个可走，矩阵B表示第i个不可走。有些地方x不能走，那么我只要用矩阵加速求出第x-1个矩阵C，那么第x个矩阵就是C*B，最后得出第n个矩阵</li>
</ul>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>dp[n] &#x3D; dp[n-1] + dp[n-2] + dp[n-3] (n&gt;&#x3D;3)所以我们第一个矩阵是从2开始的，小于2的方案要手动打出来</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: a.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: liangxianfeng</span></span><br><span class="line"><span class="comment">	&gt; Mail:   641587852@qq.com</span></span><br><span class="line"><span class="comment">	&gt; Created Time: 2016年05月13日 星期五 18时57分55秒</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,n) for(int i =0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLR(x) memset(x,0,sizeof x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prln(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt;  endl; </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rec</span>&#123;</span><br><span class="line">    ll num[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">Rec</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) num[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> num[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Rec</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)&#123;</span><br><span class="line">                num[i][j] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Rec <span class="keyword">operator</span> * (<span class="type">const</span> Rec&amp; rhs)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="function">Rec <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k)&#123;</span><br><span class="line">                    ans.num[i][j] += num[i][k]*rhs.num[k][j]; </span><br><span class="line">                &#125;</span><br><span class="line">                ans.num[i][j] %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;init;</span><br><span class="line"><span class="function">Rec <span class="title">ret</span><span class="params">(<span class="type">const</span> Rec &amp;x, ll y)</span></span>&#123;</span><br><span class="line">    Rec ans, base = x;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans = ans*base;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        base = base*base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10</span>];</span><br><span class="line">ll x[<span class="number">600</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;/home/zeroxf/桌面/in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="comment">//freopen(&quot;/home/zeroxf/桌面/out.txt&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span>  m;</span><br><span class="line">        ll n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span> x);</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x[i]);</span><br><span class="line">        <span class="built_in">sort</span>(x+<span class="number">1</span>, x+m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(x[<span class="number">1</span>] &lt; <span class="number">3</span>) vis[x[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[<span class="number">2</span>] &lt; <span class="number">3</span>) vis[x[<span class="number">2</span>]] = <span class="literal">true</span>;</span><br><span class="line">        ll ans1, ans2;</span><br><span class="line">        <span class="keyword">if</span>(vis[<span class="number">1</span>]) ans1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> ans1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[<span class="number">2</span>]) ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> ans2 = ans1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans1);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans2);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Rec <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">Rec <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        a.num[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        a.num[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        a.num[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        a.num[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        b.num[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        b.num[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        Rec ans;</span><br><span class="line">        ll last = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x[i] &lt;= <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans = ans*<span class="built_in">ret</span>(a,x[i]-last<span class="number">-1</span>);</span><br><span class="line">            ans = ans*b;</span><br><span class="line">            last = x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans*<span class="built_in">ret</span>(a,n-last);</span><br><span class="line">        ll c = ans2*ans.num[<span class="number">0</span>][<span class="number">0</span>] + ans1*ans.num[<span class="number">1</span>][<span class="number">0</span>] + ans.num[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">        c = c%MOD;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>川大重大联合赛</category>
        <category>第二场联合赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>矩阵优化</tag>
      </tags>
  </entry>
</search>
